CODEBASE COMPILATION
Generated: 2026-01-15T09:32:43.030Z
Root Directory: /home/raj/Desktop/Upgrades/Medswift
================================================================================

================================================================================
FILE: code.js
================================================================================

import fs from 'fs';
import path from 'path';

// Configuration
const CONFIG = {
  rootDir: './', // Change this to your project root
  outputFile: 'codebase_output.txt',
  includeExtensions: ['.ts', '.tsx', '.js', '.jsx', '.json', '.css', '.html'], // Add/remove as needed
  excludeDirs: ['node_modules', 'dist', 'build', '.git', 'coverage', '.next'], // Folders to skip
  excludeFiles: ['package-lock.json', 'yarn.lock', '.DS_Store','.env' ] // Files to skip
};

// Store all file contents
let output = '';
let fileCount = 0;

// Recursive function to read directory
function readDirectory(dirPath) {
  const items = fs.readdirSync(dirPath);

  items.forEach(item => {
    const fullPath = path.join(dirPath, item);
    const stat = fs.statSync(fullPath);

    if (stat.isDirectory()) {
      // Skip excluded directories
      if (!CONFIG.excludeDirs.includes(item)) {
        readDirectory(fullPath);
      }
    } else if (stat.isFile()) {
      const ext = path.extname(item);
      
      // Check if file should be included
      if (CONFIG.includeExtensions.includes(ext) && !CONFIG.excludeFiles.includes(item)) {
        try {
          const content = fs.readFileSync(fullPath, 'utf8');
          const relativePath = path.relative(CONFIG.rootDir, fullPath);
          
          // Add file separator and content
          output += `\n${'='.repeat(80)}\n`;
          output += `FILE: ${relativePath}\n`;
          output += `${'='.repeat(80)}\n\n`;
          output += content;
          output += `\n\n`;
          
          fileCount++;
          console.log(`‚úì Processed: ${relativePath}`);
        } catch (err) {
          console.error(`‚úó Error reading ${fullPath}:`, err.message);
        }
      }
    }
  });
}

// Main execution
console.log('Starting codebase compilation...\n');
console.log(`Root directory: ${path.resolve(CONFIG.rootDir)}`);
console.log(`Output file: ${CONFIG.outputFile}\n`);

// Add header to output
output += `CODEBASE COMPILATION\n`;
output += `Generated: ${new Date().toISOString()}\n`;
output += `Root Directory: ${path.resolve(CONFIG.rootDir)}\n`;
output += `${'='.repeat(80)}\n`;

// Start reading from root
readDirectory(CONFIG.rootDir);

// Write output file
fs.writeFileSync(CONFIG.outputFile, output, 'utf8');

console.log(`\n${'='.repeat(80)}`);
console.log(`‚úì Compilation complete!`);
console.log(`‚úì Total files processed: ${fileCount}`);
console.log(`‚úì Output saved to: ${path.resolve(CONFIG.outputFile)}`);
console.log(`‚úì File size: ${(fs.statSync(CONFIG.outputFile).size / 1024 / 1024).toFixed(2)} MB`);
console.log(`${'='.repeat(80)}`);


================================================================================
FILE: package.json
================================================================================

{
  "name": "Medswift",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "dev": "tsx watch src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "type": "module",
  "keywords": [],
  "author": "",
  "license": "ISC",
  "packageManager": "pnpm@10.26.1",
  "devDependencies": {
    "@types/bcrypt": "^6.0.0",
    "@types/cookie-parser": "^1.4.10",
    "@types/cors": "^2.8.19",
    "@types/express": "^5.0.6",
    "@types/ioredis": "^5.0.0",
    "@types/jsonwebtoken": "^9.0.10",
    "@types/node": "^25.0.1",
    "ts-node": "^10.9.2",
    "tsx": "^4.21.0",
    "typescript": "^5.9.3"
  },
  "dependencies": {
    "bcrypt": "^6.0.0",
    "bullmq": "^5.66.2",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.2.1",
    "ioredis": "^5.8.2",
    "jsonwebtoken": "^9.0.3",
    "mongoose": "^9.0.1",
    "redis": "^5.10.0",
    "socket.io": "^4.8.1",
    "zod": "^4.2.1"
  }
}


================================================================================
FILE: src/app.ts
================================================================================

import express, {
  type NextFunction,
  type Request,
  type Response,
  type Application,
} from "express";
import cors from "cors";
import cookieParser from "cookie-parser";
import { ApiError } from "./shared/utils/ApiError.js";
import { ApiResponse } from "./shared/utils/ApiResponce.js";

//UserRoutes import
import { userRoutes } from "./modules/user/routes/user.routes.js";

//AmbulanceRoutes import
import { ambulanceRoutes } from './modules/ambulance/routes/ambulance.routes.js';

//HospitalRoutes
import { hospitalRoutes } from './modules/hospital/routes/hospital.routes.js';

//AdminRoutes import
import { adminRoutes } from "./modules/admin/routes/admin.routes.js";

//TripRoutes import
import { tripRoutes } from "./modules/trip/routes/trip.routes.js";

const app: Application = express();

app.use(
  cors({
    origin: "http://localhost:5000",
    credentials: true,
  })
);

app.use(express.json({ limit: "12kb" }));
app.use(express.urlencoded({ extended: true, limit: "12kb" }));
app.use(cookieParser());

//UserRoutes
app.use("/api/v2/user", userRoutes)

//AmbulanceRoutes
app.use("/api/v2/ambulance", ambulanceRoutes)

//AdminRoutes
app.use("/api/v2/admin", adminRoutes)

//HospitalRoutes
app.use("/api/v2/hospital", hospitalRoutes)

//TripRoutes
app.use("/api/v2/trip", tripRoutes)

// Global Error Handler middleware
app.use((err: any, req: Request, res: Response, next: NextFunction) => {
  // If the error is a known ApiError
  if (err instanceof ApiError) {
    return res
      .status(err.statusCode)
      .json(new ApiResponse(err.statusCode, err.data, err.message));
  }

  // Log the unexpected error for debugging on the server console
  console.error("Internal Server Error:", err);

  // FIX: Use 'res' instead of 'err' to send the response
  return res
    .status(500)
    .json(new ApiResponse(500, null, "Internal Server Error"));
});
export { app };



================================================================================
FILE: src/config/Dbconnecton.ts
================================================================================

import mongoose from "mongoose";
import dotenv from "dotenv";

dotenv.config({
  path: "./.env",
});

const MONGO_URI = process.env.MONGO_URI as string;

if (!MONGO_URI) {
  throw new Error("MONGO_URI is not defined in environment variables.");
}

const ConnectDb = async (): Promise<void> => {
  try {
    const connectionInstance = await mongoose.connect(MONGO_URI, {
      autoIndex: false,
      serverSelectionTimeoutMS: 5000,
    });
    console.log(
      `\nMongoDB connected !! DB HOST: ${connectionInstance.connection.host}:${connectionInstance.connection.port}`
    );
  } catch (error) {
    console.error("Connection Error", error);
    process.exit(1);
  }
};

process.on("SIGINT", async () => {
  await mongoose.connection.close();
  console.log("MongoDB disconnected (SIGINT)");
  process.exit(0);
});

export { ConnectDb };



================================================================================
FILE: src/config/env.ts
================================================================================

import { configDotenv } from "dotenv";
configDotenv({
  path: "./.env",
});

const PORT = process.env.PORT as string
const MONGO_URI = process.env.MONGO_URI as string;
const ACCESS_TOKEN_SECRET = process.env.ACCESS_TOKEN_SECRET as string;
const REFRESH_TOKEN_SECRET = process.env.REFRESH_TOKEN_SECRET as string;
const NODE_ENV = process.env.NODE_ENV as string;
const REDIS_URL= process.env.REDIS_URL as string
const ADMIN_CREATION_SECRET = process.env.ADMIN_CREATION_SECRET as string

export { PORT, MONGO_URI, ACCESS_TOKEN_SECRET, REFRESH_TOKEN_SECRET, NODE_ENV, REDIS_URL, ADMIN_CREATION_SECRET };



================================================================================
FILE: src/config/queue.config.ts
================================================================================

import { Queue, Worker } from "bullmq";
import type { QueueOptions, WorkerOptions, ConnectionOptions } from "bullmq";
import { REDIS_URL } from "./env.js";

const queueConnection: ConnectionOptions = {
  url: REDIS_URL, 
  // BullMQ options for robustness
  retryStrategy: function (times) {
    return Math.max(Math.min(Math.exp(times), 20000), 1000);
  },
};



================================================================================
FILE: src/config/redis.ts
================================================================================

import { createClient } from "redis";
import type { RedisClientType } from 'redis'
import { REDIS_URL } from "./env.js";

const redis: RedisClientType= createClient({
  url: REDIS_URL,
});

redis.on("connect", () => {
  console.log("connected to redis");
});

redis.on("err", () => {
  console.log("Error in connecting to redis");
});

export default redis;



================================================================================
FILE: src/index.ts
================================================================================

import { app } from "./app.js";
import dotenv from "dotenv";
import { ConnectDb } from "./config/Dbconnecton.js";
import { PORT } from "./config/env.js";
import redis from "./config/redis.js";
import { initializeSocket } from './shared/infra/sockets/socket.config.js';
import { createServer } from "node:http";


const StartServer = async () => {
  try {
    // Connect to MongoDB
    await ConnectDb();

    // Connect to Redis
    await redis.connect();

    // Create HTTP server (needed for Socket.IO)
    const httpServer = createServer(app);

    // Initialize Socket.IO
    initializeSocket(httpServer);

    // Start listening
    httpServer.listen(PORT, () => {
      console.log(`üöÄ Server is running on http://localhost:${PORT}`);
      console.log(`üì° Socket.IO ready for connections`);
    });
  } catch (error) {
    console.log("Error in connection to Database: ", error);
    process.exit(1);
  }
};

StartServer()



================================================================================
FILE: src/modules/admin/admin.dto/admin.dto.ts
================================================================================

import { z } from "zod";

// Admin Registration Schema
// (In production, we might want to remove this or protect it with a 'secret key' so random people can't register as admin)
export const createAdminSchema = z.object({
  name: z.string().trim().min(1, "Name is required"),
  email: z
    .string()
    .trim()
    .email("Invalid email format")
    .transform((val) => val.toLowerCase()),
  password: z.string().min(8, "Password must be at least 8 characters long"),
  secretKey: z.string().min(1, "Secret key required to create admin"), // Simple security measure
});

// Admin Login Schema
export const adminLoginSchema = z.object({
  email: z
    .string()
    .trim()
    .email("Invalid email format")
    .transform((val) => val.toLowerCase()),
  password: z.string().min(1, "Password is required"),
});

export type CreateAdminInput = z.infer<typeof createAdminSchema>;
export type AdminLoginInput = z.infer<typeof adminLoginSchema>;


================================================================================
FILE: src/modules/admin/controllers/admin.controller.ts
================================================================================

import type { Request, Response } from "express";
import { asyncHandler } from "../../../shared/utils/AsyncHandler.js";
import { ApiError } from "../../../shared/utils/ApiError.js";
import { ApiResponse } from "../../../shared/utils/ApiResponce.js";
import { Admin } from "../models/admin.model.js";
import { adminLoginSchema, createAdminSchema } from "../admin.dto/admin.dto.js";
import { NODE_ENV , ADMIN_CREATION_SECRET} from "../../../config/env.js";

// A simple hardcoded secret for creating admins
// In production, move this to .env


/**
 * @description Register a new Admin (Protected by Secret Key)
 * @route POST /api/v2/admin/register
*/
export const registerAdmin = asyncHandler(async (req: Request, res: Response) => {
  const validation = createAdminSchema.safeParse(req.body);
  if (!validation.success) {
    throw new ApiError(400, "Validation Failed", validation.error.issues);
  }
  
  const { name, email, password, secretKey } = validation.data;
  
  // Security Check
  if (secretKey !== ADMIN_CREATION_SECRET) {
    throw new ApiError(403, "Forbidden: Invalid Secret Key");
  }
  
  const existingAdmin = await Admin.findOne({ email });
  if (existingAdmin) {
    throw new ApiError(409, "Admin with this email already exists");
  }
  
  const admin = await Admin.create({ name, email, password });
  
  const createdAdmin = await Admin.findById(admin._id).select("-password -refreshToken");
  
  res.status(201).json(new ApiResponse(201, createdAdmin, "Admin created successfully"));
});

/**
 * @description Login Admin
 * @route POST /api/v2/admin/login
*/
export const loginAdmin = asyncHandler(async (req: Request, res: Response) => {
  const validation = adminLoginSchema.safeParse(req.body);
  if (!validation.success) {
    throw new ApiError(400, "Validation Failed", validation.error.issues);
  }
  
  const { email, password } = validation.data;
  
  const admin = await Admin.findOne({ email }).select("+password");
  if (!admin) {
    throw new ApiError(401, "Invalid credentials");
  }

  const isPasswordValid = await admin.checkPassword(password);
  if (!isPasswordValid) {
    throw new ApiError(401, "Invalid credentials");
  }
  
  const accessToken = admin.GetAccessToken();
  const refreshToken = admin.GetRefreshToken();
  
  admin.refreshToken = refreshToken;
  await admin.save({ validateBeforeSave: false });
  
  const loggedInAdmin = await Admin.findById(admin._id).select("-password -refreshToken");
  
  const cookieOptions = {
    httpOnly: true,
    secure: NODE_ENV === "production",
    sameSite: "strict" as const,
  };
  
  res
  .status(200)
  .cookie("accessToken", accessToken, { ...cookieOptions, maxAge: 15 * 60 * 1000 })
  .cookie("refreshToken", refreshToken, { ...cookieOptions, maxAge: 7 * 24 * 60 * 60 * 1000 })
  .json(
    new ApiResponse(
      200,
      { admin: loggedInAdmin, accessToken, refreshToken },
      "Admin logged in successfully"
    )
  );
});

/**
 * @description Logout Admin
 * @route POST /api/v2/admin/logout
*/
export const logoutAdmin = asyncHandler(async (req: Request, res: Response) => {
  const adminId = (req as any).admin?._id;
  
  await Admin.findByIdAndUpdate(adminId, { $set: { refreshToken: null } });

  const cookieOptions = {
    httpOnly: true,
    secure: NODE_ENV === "production",
    sameSite: "strict" as const,
  };
  
  res
  .status(200)
  .clearCookie("accessToken", cookieOptions)
  .clearCookie("refreshToken", cookieOptions)
  .json(new ApiResponse(200, {}, "Admin logged out successfully"));
});

/**
 * @description Get Admin Profile
 * @route GET /api/v2/admin/me
*/
export const getAdminProfile = asyncHandler(async (req: Request, res: Response) => {
  res.status(200).json(new ApiResponse(200, (req as any).admin, "Admin profile"));
});



import redis from "../../../config/redis.js";
/**
 * @description Debug: View Redis keys (Admin only)
 * @route GET /api/v2/admin/debug/redis
*/
export const debugRedisKeys = asyncHandler(async (req: Request, res: Response) => {
  try {
    // Get all socket mappings
    const socketMapping = await redis.hGetAll("socket:mapping");
    
    // Get all location keys
    const locationKeys = await redis.keys("location:*");
    const locations: any = {};
    for (const key of locationKeys) {
      const data = await redis.get(key);
      locations[key] = data ? JSON.parse(data) : null;
    }
    
    // Get all trip participant keys
    const tripKeys = await redis.keys("trip_participants:*");
    const tripParticipants: any = {};
    for (const key of tripKeys) {
      const members = await redis.sMembers(key);
      tripParticipants[key] = members;
    }
    
    // Get ambulance locations from geo index
    const ambulanceGeoCount = await redis.zCard("ambulance_locations");
    const ambulanceGeoMembers = await redis.zRange("ambulance_locations", 0, -1);
    
    res.status(200).json(
      new ApiResponse(
        200,
        {
          socketMapping: Object.entries(socketMapping).map(([socketId, data]) => ({
            socketId,
            ...JSON.parse(data as string)
          })),
          locations,
          tripParticipants,
          ambulanceGeo: {
            count: ambulanceGeoCount,
            members: ambulanceGeoMembers
          }
        },
        "Redis debug data"
      )
    );
  } catch (error) {
    console.error("Redis debug error:", error);
    throw new ApiError(500, "Failed to fetch Redis data");
  }
});


================================================================================
FILE: src/modules/admin/models/admin.model.ts
================================================================================

import mongoose, { Document, Schema } from "mongoose";
import {
  hashPassword,
  verifyPassword,
  generateAccessToken,
  generateRefreshToken,
} from "../../../shared/utils/auth.util.js";

export interface IAdmin extends Document {
  name: string;
  email: string;
  password?: string;
  refreshToken?: string | null;

  // Methods
  checkPassword(password: string): Promise<boolean>;
  GetAccessToken(): string;
  GetRefreshToken(): string;
}

const AdminSchema = new Schema<IAdmin>(
  {
    name: {
      type: String,
      required: true,
      trim: true,
    },
    email: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      lowercase: true,
    },
    password: {
      type: String,
      required: true,
      select: false, // Security: Never return password by default
    },
    refreshToken: {
      type: String,
      default: null,
      select: false,
    },
  },
  { timestamps: true }
);

// Encrypt password before saving
AdminSchema.pre<IAdmin>("save", async function () {
  if (!this.isModified("password")) return;
  this.password = await hashPassword(this.password as string);
});

// Methods
AdminSchema.methods.checkPassword = async function (enteredPassword: string) {
  if (!this.password) return false;
  return await verifyPassword(enteredPassword, this.password);
};

AdminSchema.methods.GetAccessToken = function () {
  return generateAccessToken({ id: this._id, role: "admin" });
};

AdminSchema.methods.GetRefreshToken = function () {
  return generateRefreshToken({ id: this._id, role: "admin" });
};

export const Admin = mongoose.model<IAdmin>("Admin", AdminSchema);



================================================================================
FILE: src/modules/admin/routes/admin.routes.ts
================================================================================

import { Router } from "express";
import {
  registerAdmin,
  loginAdmin,
  logoutAdmin,
  getAdminProfile,
  debugRedisKeys,
} from "../controllers/admin.controller.js";
import { verifyAdminJWT } from "../../../shared/middlewares/auth.middleware.js";

const router = Router();

// Public Routes
router.post("/register", registerAdmin); // In production, hide this!
router.post("/login", loginAdmin);

// Protected Routes (Require Admin Token)
router.post("/logout", verifyAdminJWT, logoutAdmin);
router.get("/me", verifyAdminJWT, getAdminProfile);
router.get("/debug/redis", verifyAdminJWT, debugRedisKeys)

export const adminRoutes: ReturnType<typeof Router> = router;



================================================================================
FILE: src/modules/ambulance/ambulance.dto/ambulance.dto.ts
================================================================================

import { z } from "zod";

// Zod schema for ambulance location (GeoJSON Point)
const locationSchema = z.object({
  type: z.literal("Point"),
  coordinates: z.tuple([
    z.number().min(-180).max(180), // longitude
    z.number().min(-90).max(90),   // latitude
  ]),
});

// Zod schema for ambulance registration/creation
export const createAmbulanceSchema = z.object({
  driverName: z.string().trim().min(1, "Driver name is required"),
  driverPhone: z
    .string()
    .trim()
    .min(10, "Phone number must be at least 10 digits")
    .regex(/^[0-9+()-\s]+$/, "Invalid phone number format"),
  password: z
    .string()
    .min(6, "Password must be at least 6 characters long"),
  vehicleNumber: z
    .string()
    .trim()
    .min(1, "Vehicle number is required")
    .transform((val) => val.toUpperCase()),
  status: z.enum(["ready", "on-trip", "offline"]).default("offline"),
  location: locationSchema,
});

// Zod schema for ambulance update (all fields optional)
export const updateAmbulanceSchema = z.object({
  driverName: z.string().trim().min(1).optional(),
  driverPhone: z
    .string()
    .trim()
    .min(10, "Phone number must be at least 10 digits")
    .regex(/^[0-9+()-\s]+$/, "Invalid phone number format")
    .optional(),
  password: z
    .string()
    .min(6, "Password must be at least 6 characters long")
    .optional(),
  vehicleNumber: z
    .string()
    .trim()
    .min(1)
    .transform((val) => val.toUpperCase())
    .optional(),
  status: z.enum(["ready", "on-trip", "offline"]).optional(),
  location: locationSchema.optional(),
});

// Zod schema for ambulance login
export const ambulanceLoginSchema = z.object({
  driverPhone: z
    .string()
    .trim()
    .min(1, "Phone number is required"),
  password: z
    .string()
    .min(1, "Password is required"),
});

// Zod schema for updating ambulance status
export const updateStatusSchema = z.object({
  status: z.enum(["ready", "on-trip", "offline"]),
});

// Zod schema for updating ambulance location
export const updateLocationSchema = z.object({
  location: locationSchema,
});

// Zod schema for nearby ambulance search query
export const nearbyAmbulanceQuerySchema = z.object({
  longitude: z.coerce.number().min(-180).max(180),
  latitude: z.coerce.number().min(-90).max(90),
  maxDistance: z.coerce.number().positive().default(5000), // in meters
  status: z.enum(["ready", "on-trip", "offline"]).optional(),
});

// Type exports for TypeScript
export type CreateAmbulanceInput = z.infer<typeof createAmbulanceSchema>;
export type UpdateAmbulanceInput = z.infer<typeof updateAmbulanceSchema>;
export type AmbulanceLoginInput = z.infer<typeof ambulanceLoginSchema>;
export type UpdateStatusInput = z.infer<typeof updateStatusSchema>;
export type UpdateLocationInput = z.infer<typeof updateLocationSchema>;
export type NearbyAmbulanceQuery = z.infer<typeof nearbyAmbulanceQuerySchema>;


================================================================================
FILE: src/modules/ambulance/controllers/ambulance.controller.ts
================================================================================

import { asyncHandler } from "../../../shared/utils/AsyncHandler.js";
import { ApiError } from "../../../shared/utils/ApiError.js";
import { ApiResponse } from "../../../shared/utils/ApiResponce.js";
import {
  ambulanceLoginSchema,
  createAmbulanceSchema,
} from "../ambulance.dto/ambulance.dto.js";
import type { Request, Response } from "express";
import { Ambulance } from "../model/ambulance.model.js";
import { NODE_ENV } from "../../../config/env.js";
import {
  syncAmbulancetoRedis,
  removeAmbulanceFromRedis,
  findNearbyAmbulances,
  getActiveAmbulanceCount,
  getAllActiveAmbulanceIds
} from "../services/ambulance.service.js";

/**
 * @description Register a new ambulance
 * @route POST /api/v2/ambulances/register
 * @access Public
 */
const registerAmbulance = asyncHandler(async (req: Request, res: Response) => {
  // Validate request body
  const validationResult = createAmbulanceSchema.safeParse(req.body);

  if (!validationResult.success) {
    throw new ApiError(400, "Validation failed", validationResult.error.issues);
  }

  const { driverName, driverPhone, password, vehicleNumber, status, location } =
    validationResult.data;

  // Check if ambulance already exists
  const existingAmbulance = await Ambulance.findOne({
    $or: [{ driverPhone }, { vehicleNumber }],
  });

  if (existingAmbulance) {
    throw new ApiError(
      409,
      existingAmbulance.driverPhone === driverPhone
        ? "Ambulance with this phone number already exists"
        : "Ambulance with this vehicle number already exists"
    );
  }

  // Create ambulance
  const ambulance = await Ambulance.create({
    driverName,
    driverPhone,
    password,
    vehicleNumber,
    status: status || "offline",
    location,
  });

  // Fetch ambulance without password and refreshToken
  const createdAmbulance = await Ambulance.findById(ambulance._id).select(
    "-password -refreshToken"
  );

  if (!createdAmbulance) {
    throw new ApiError(500, "Failed to create ambulance");
  }

  // Generate tokens
  const accessToken = createdAmbulance.GetAccessToken();
  const refreshToken = createdAmbulance.GetRefreshToken();

  // Save refresh token to database
  createdAmbulance.refreshToken = refreshToken;
  await createdAmbulance.save({ validateBeforeSave: false });

  // Set cookies
  const cookieOptions = {
    httpOnly: true,
    secure: NODE_ENV === "production",
    sameSite: "strict" as const,
  };

  res
    .status(201)
    .cookie("accessToken", accessToken, {
      ...cookieOptions,
      maxAge: 15 * 60 * 1000,
    }) // 15 minutes
    .cookie("refreshToken", refreshToken, {
      ...cookieOptions,
      maxAge: 7 * 24 * 60 * 60 * 1000,
    }) // 7 days
    .json(
      new ApiResponse(
        201,
        {
          ambulance: createdAmbulance,
          accessToken,
          refreshToken,
        },
        "Ambulance registered successfully"
      )
    );
});

/**
 * @description Login ambulance with phone number
 * @route POST /api/v2/ambulances/login
 * @access Public
 */
const loginAmbulance = asyncHandler(async (req: Request, res: Response) => {
  // Validate request body
  const validationResult = ambulanceLoginSchema.safeParse(req.body);

  if (!validationResult.success) {
    throw new ApiError(400, "Validation failed", validationResult.error.issues);
  }

  const { driverPhone, password } = validationResult.data;

  // Find ambulance with password field
  const ambulance = await Ambulance.findOne({ driverPhone }).select(
    "+password"
  );

  if (!ambulance) {
    throw new ApiError(401, "Invalid credentials");
  }

  // Verify password
  const isPasswordValid = await ambulance.checkPassword(password);

  if (!isPasswordValid) {
    throw new ApiError(401, "Invalid credentials");
  }

  // Generate tokens
  const accessToken = ambulance.GetAccessToken();
  const refreshToken = ambulance.GetRefreshToken();

  // Save refresh token to database
  ambulance.refreshToken = refreshToken;
  await ambulance.save({ validateBeforeSave: false });

  // Fetch ambulance without password and refreshToken
  const loggedInAmbulance = await Ambulance.findById(ambulance._id).select(
    "-password -refreshToken"
  );

  // ---------------------------------------------------------
  // 1. REDIS SYNC: If they log in and are "ready", put them in Redis immediately
  // ---------------------------------------------------------
  await syncAmbulancetoRedis(ambulance);

  // Set cookies
  const cookieOptions = {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict" as const,
  };

  res
    .status(200)
    .cookie("accessToken", accessToken, {
      ...cookieOptions,
      maxAge: 15 * 60 * 1000,
    }) // 15 minutes
    .cookie("refreshToken", refreshToken, {
      ...cookieOptions,
      maxAge: 7 * 24 * 60 * 60 * 1000,
    }) // 7 days
    .json(
      new ApiResponse(
        200,
        {
          ambulance: loggedInAmbulance,
          accessToken,
          refreshToken,
        },
        "Ambulance logged in successfully"
      )
    );
});

/**
 * @description Logout ambulance
 * @route POST /api/v2/ambulances/logout
 * @access Private
 */
const logoutAmbulance = asyncHandler(async (req: Request, res: Response) => {
  const ambulanceId = (req as any).ambulance?._id;

  if (!ambulanceId) {
    throw new ApiError(401, "Unauthorized");
  }

  // Clear refresh token from database
  await Ambulance.findByIdAndUpdate(
    ambulanceId,
    {
      $set: { refreshToken: null },
    },
    { new: true }
  );

  // ---------------------------------------------------------
  // 2. REDIS SYNC: Explicitly remove them from the pool
  // ---------------------------------------------------------
  await removeAmbulanceFromRedis(ambulanceId.toString());

  // Clear cookies
  const cookieOptions = {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict" as const,
  };

  res
    .status(200)
    .clearCookie("accessToken", cookieOptions)
    .clearCookie("refreshToken", cookieOptions)
    .json(new ApiResponse(200, {}, "Ambulance logged out successfully"));
});

/**
 * @description Update ambulance status
 * @route PATCH /api/v2/ambulances/status
 * @access Private
 */
const updateAmbulanceStatus = asyncHandler(
  async (req: Request, res: Response) => {
    const ambulanceId = (req as any).ambulance?._id;

    if (!ambulanceId) {
      throw new ApiError(401, "Unauthorized");
    }

    const { status } = req.body;

    if (!status || !["ready", "on-trip", "offline"].includes(status)) {
      throw new ApiError(
        400,
        "Invalid status. Must be: ready, on-trip, or offline"
      );
    }

    const ambulance = await Ambulance.findByIdAndUpdate(
      ambulanceId,
      { status },
      { new: true, runValidators: true }
    ).select("-password -refreshToken");

    if (!ambulance) {
      throw new ApiError(404, "Ambulance not found");
    }

    // ---------------------------------------------------------
    // 3. REDIS SYNC: Add or Remove based on the new status
    // ---------------------------------------------------------
    await syncAmbulancetoRedis(ambulance);

    res
      .status(200)
      .json(
        new ApiResponse(200, ambulance, "Ambulance status updated successfully")
      );
  }
);

/**
 * @description Update ambulance location
 * @route PATCH /api/v2/ambulances/location
 * @access Private
 */
const updateAmbulanceLocation = asyncHandler(
  async (req: Request, res: Response) => {
    const ambulanceId = (req as any).ambulance?._id;

    if (!ambulanceId) {
      throw new ApiError(401, "Unauthorized");
    }

    // Since we are using Zod middleware in the route (ambulance.routes.ts), 
    // req.body is guaranteed to have the correct structure if we reach here.
    // DTO: { location: { type: "Point", coordinates: [lng, lat] } }
    const { location } = req.body;

    // Double-check validation (Optional but safe)
    if (
      !location ||
      location.type !== "Point" ||
      !Array.isArray(location.coordinates) ||
      location.coordinates.length !== 2
    ) {
      throw new ApiError(
        400,
        "Invalid location format. Expected GeoJSON Point with [longitude, latitude]"
      );
    }

    // Update MongoDB
    const ambulance = await Ambulance.findByIdAndUpdate(
      ambulanceId,
      { location },
      { new: true, runValidators: true }
    ).select("-password -refreshToken");

    if (!ambulance) {
      throw new ApiError(404, "Ambulance not found");
    }

    // ---------------------------------------------------------
    // 4. REDIS SYNC: If they move, update Redis so dispatch finds them at the NEW spot
    // ---------------------------------------------------------
    // Note: If their status is "on-trip", this will ensure they stay removed from the "ready" pool
    await syncAmbulancetoRedis(ambulance);

    res
      .status(200)
      .json(
        new ApiResponse(
          200,
          ambulance,
          "Ambulance location updated successfully"
        )
      );
  }
);

/**
 * @description Get current logged in ambulance profile
 * @route GET /api/v2/ambulance/me
 * @access Private
 */
const getAmbulanceProfile = asyncHandler(
  async (req: Request, res: Response) => {
    // req.ambulance is populated by verifyAmbulanceJWT middleware
    // It is already sanitized (password removed) by the middleware
    const ambulance = req.ambulance;

    if (!ambulance) {
      throw new ApiError(401, "Unauthorized - Ambulance not logged in");
    }

    res
      .status(200)
      .json(
        new ApiResponse(
          200,
          ambulance,
          "Ambulance profile fetched successfully"
        )
      );
  }
);

/**
 * @description Find nearby ambulances with automatic failover (5km ‚Üí 10km ‚Üí 17km ‚Üí 30km)
 * @route GET /api/v2/ambulance/nearby
 * @access Public
 */
const getNearbyAmbulances = asyncHandler(
  async (req: Request, res: Response) => {
    const { longitude, latitude, limit } = req.query;

    // Validate required parameters
    if (!longitude || !latitude) {
      throw new ApiError(
        400,
        "Longitude and latitude are required query parameters"
      );
    }

    // Parse and validate values
    const lng = parseFloat(longitude as string);
    const lat = parseFloat(latitude as string);
    const maxResults = limit ? parseInt(limit as string, 10) : 10;

    // Validate ranges
    if (isNaN(lng) || lng < -180 || lng > 180) {
      throw new ApiError(400, "Invalid longitude. Must be between -180 and 180");
    }

    if (isNaN(lat) || lat < -90 || lat > 90) {
      throw new ApiError(400, "Invalid latitude. Must be between -90 and 90");
    }

    if (isNaN(maxResults) || maxResults <= 0 || maxResults > 50) {
      throw new ApiError(400, "Invalid limit. Must be between 1 and 50");
    }

    // Find nearby ambulances with automatic failover
    const ambulances = await findNearbyAmbulances(lng, lat, maxResults);

    // Check if ambulances were found
    if (ambulances.length === 0) {
      return res.status(200).json(
        new ApiResponse(
          200,
          {
            count: 0,
            ambulances: [],
            message: "No ambulance found nearby. Emergency request sent to admin. Ambulance is on the way."
          },
          "No ambulances available within 30km"
        )
      );
    }

    // Return found ambulances
    res.status(200).json(
      new ApiResponse(
        200,
        {
          count: ambulances.length,
          ambulances: ambulances,
        },
        `Found ${ambulances.length} nearby ambulance(s)`
      )
    );
  }
);
/**
 * @description Get statistics about active ambulances in Redis
 * @route GET /api/v2/ambulance/stats
 * @access Admin only
 */
const getAmbulanceStats = asyncHandler(async (req: Request, res: Response) => {
  const activeCount = await getActiveAmbulanceCount();
  const activeIds = await getAllActiveAmbulanceIds();

  res.status(200).json(
    new ApiResponse(
      200,
      {
        activeAmbulances: activeCount,
        ambulanceIds: activeIds,
      },
      "Ambulance statistics retrieved successfully"
    )
  );
});
export {
  registerAmbulance,
  loginAmbulance,
  logoutAmbulance,
  updateAmbulanceStatus,
  updateAmbulanceLocation,
  getAmbulanceProfile,
  getNearbyAmbulances,
  getAmbulanceStats
};



================================================================================
FILE: src/modules/ambulance/model/ambulance.model.ts
================================================================================

import mongoose, { Document, Schema } from "mongoose";
import {
  hashPassword,
  verifyPassword,
  generateAccessToken,
  generateRefreshToken,
} from "../../../shared/utils/auth.util.js"; // Ensure this path matches your folder structure

// 1. Define the TypeScript Interface
export interface IAmbulance extends Document {
  driverName: string;
  driverPhone: string;
  password?: string;
  vehicleNumber: string;
  status: "ready" | "on-trip" | "offline"; // Strict status states
  location: {
    type: "Point";
    coordinates: [number, number]; // [lng, lat]
  };
  refreshToken?: string | null;

  // Methods defined on the schema
  checkPassword(password: string): Promise<boolean>;
  GetAccessToken(): string;
  GetRefreshToken(): string;
}

// 2. Define the Mongoose Schema
const AmbulanceSchema = new Schema<IAmbulance>(
  {
    driverName: {
      type: String,
      required: true,
      trim: true,
    },
    driverPhone: {
      type: String,
      required: true,
      unique: true,
      trim: true,
    },
    password: {
      type: String,
      required: true,
      minlength: 6,
      select: false, // Security: Do not return password by default
    },
    vehicleNumber: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      uppercase: true, // Auto-uppercase vehicle numbers (e.g., KA01AB1234)
    },
    status: {
      type: String,
      enum: ["ready", "on-trip", "offline"],
      default: "offline",
      required: true,
    },
    location: {
      type: {
        type: String,
        enum: ["Point"],
        required: true,
        default: "Point",
      },
      coordinates: {
        type: [Number], // [lng, lat]
        required: true,
      },
    },
    refreshToken: {
      type: String,
      default: null,
      select: false,
    },
  },
  { timestamps: true }
);

// 3. Add Geospatial Indexing
AmbulanceSchema.index({ location: "2dsphere" });

// 4. Schema Hooks (Pre-save Middleware)
AmbulanceSchema.pre<IAmbulance>("save", async function (this: IAmbulance & Document) {
  // Only hash the password if it has been modified or is new
  if (!this.isModified("password")) return;

  // Use the imported utility function
  this.password = await hashPassword(this.password as string);
});

// 5. Schema Methods
AmbulanceSchema.methods.checkPassword = async function (
  this: IAmbulance,
  enteredPassword: string
): Promise<boolean> {
  if (!this.password) return false;
  return await verifyPassword(enteredPassword, this.password);
};

AmbulanceSchema.methods.GetAccessToken = function (this: IAmbulance): string {
  
  return generateAccessToken({ id: this._id.toHexString(), role: "ambulance" });
};

AmbulanceSchema.methods.GetRefreshToken = function (this: IAmbulance): string {
  return generateRefreshToken({ id: this._id.toHexString(), role: "ambulance" });
};

// 6. Export the Model
export const Ambulance = mongoose.model<IAmbulance>("Ambulance", AmbulanceSchema);


================================================================================
FILE: src/modules/ambulance/routes/ambulance.routes.ts
================================================================================

import { Router } from "express";
import { z } from "zod";
import { validate } from "../../../shared/middlewares/validate.middleware.js";
import { verifyAmbulanceJWT } from "../../../shared/middlewares/auth.middleware.js";
import {
  createAmbulanceSchema,
  ambulanceLoginSchema,
  updateStatusSchema,
  updateLocationSchema,
} from "../ambulance.dto/ambulance.dto.js";
import {
  registerAmbulance,
  loginAmbulance,
  logoutAmbulance,
  updateAmbulanceStatus,
  updateAmbulanceLocation,
  getAmbulanceProfile,
  getNearbyAmbulances,
  getAmbulanceStats,
} from "../controllers/ambulance.controller.js";

const router = Router();

// ============================================
// PUBLIC ROUTES
// ============================================

/**
 * @route   POST /api/v2/ambulance/register
 * @desc    Register a new ambulance
 * @access  Public
 */
router.post(
  "/register",
  validate(z.object({ body: createAmbulanceSchema })),
  registerAmbulance
);

/**
 * @route   POST /api/v2/ambulance/login
 * @desc    Login ambulance with phone number
 * @access  Public
 */
router.post(
  "/login",
  validate(z.object({ body: ambulanceLoginSchema })),
  loginAmbulance
);

/**
 * @route   GET /api/v2/ambulance/nearby
 * @desc    Find nearby ambulances with automatic failover (5km ‚Üí 10km ‚Üí 17km ‚Üí 30km)
 * @access  Public
 * @query   longitude, latitude, limit (optional, default: 10)
 */
router.get("/nearby", getNearbyAmbulances);

// ============================================
// PROTECTED ROUTES
// ============================================

/**
 * @route   POST /api/v2/ambulance/logout
 * @desc    Logout ambulance and clear tokens
 * @access  Private
 */
router.post("/logout", verifyAmbulanceJWT, logoutAmbulance);

/**
 * @route   PATCH /api/v2/ambulance/status
 * @desc    Update ambulance status (ready/on-trip/offline)
 * @access  Private
 */
router.patch(
  "/status",
  verifyAmbulanceJWT,
  validate(z.object({ body: updateStatusSchema })),
  updateAmbulanceStatus
);

/**
 * @route   PATCH /api/v2/ambulance/location
 * @desc    Update ambulance real-time location
 * @access  Private
 */
router.patch(
  "/location",
  verifyAmbulanceJWT,
  validate(z.object({ body: updateLocationSchema })),
  updateAmbulanceLocation
);

/**
 * @route   GET /api/v2/ambulance/me
 * @desc    Get current ambulance profile
 * @access  Private
 */
router.get("/me", verifyAmbulanceJWT, getAmbulanceProfile);

/**
 * @route   GET /api/v2/ambulance/stats
 * @desc    Get active ambulance statistics
 * @access  Admin Only
 */
router.get("/stats", getAmbulanceStats);

export const ambulanceRoutes: ReturnType<typeof Router> = router;



================================================================================
FILE: src/modules/ambulance/services/ambulance.service.ts
================================================================================

import redis from "../../../config/redis.js";
import { Ambulance } from "../model/ambulance.model.js";
import type { IAmbulance } from "../model/ambulance.model.js";
import type { Types } from "mongoose";
const AMBULANCE_GEO_KEY = "ambulance_locations";

export interface IAmbulanceLocation {
  type: "Point";
  coordinates: [number, number]; // [longitude, latitude]
}
export interface IAmbulanceSyncPayload {
  _id: Types.ObjectId | string;
  status: string; // "ready" | "on-trip" | "offline"
  location: IAmbulanceLocation;
}
/**
 * Syncs the ambulance state with Redis.
 * - If status is 'ready': Adds to Redis GEO index.
 * - If status is 'busy'/'offline': Removes from Redis GEO index.
 */
const syncAmbulancetoRedis = async (
  ambulance: IAmbulanceSyncPayload | IAmbulance
): Promise<void> => {
  const { _id, status, location } = ambulance;
  const ambulanceId = _id.toString();
  try {
    // Only 'ready' ambulances should be in the search pool
    if (status === "ready" && location?.coordinates) {
      const [lng, lat] = location.coordinates;

      // Validate coordinates before sending to Redis
      if (typeof lng === "number" && typeof lat === "number") {
        // GEOADD key longitude latitude member
        await redis.geoAdd(AMBULANCE_GEO_KEY, {
          member: ambulanceId,
          longitude: lng,
          latitude: lat,
        });
        console.log(`Redis: Added ${ambulanceId} to active pool`);
      } else {
        console.warn(`Redis: Invalid coordinates for ${ambulanceId}`);
      }
    } else {
      // ZREM key member
      // We remove them if they are 'offline' OR 'on-trip' (busy)
      await redis.zRem(AMBULANCE_GEO_KEY, ambulanceId);
      console.log(
        `Redis: Removed ${ambulanceId} from active pool (Status: ${status})`
      );
    }
  } catch (error) {
    console.error("Redis Sync Error:", error);
  }
};

/**
 * Explicitly remove ambulance from Redis (used on Logout)
 */
const removeAmbulanceFromRedis = async (ambulanceId: string) => {
  try {
    await redis.zRem(AMBULANCE_GEO_KEY, ambulanceId);
    console.log("Removed ambulance from redis");
  } catch (error) {
    console.error("Redis Removal Error:", error);
  }
};

/**
 * Find nearby ambulances with automatic radius failover
 * Searches at: 5km ‚Üí 10km ‚Üí 17km ‚Üí 30km
 * @param longitude - User's longitude
 * @param latitude - User's latitude
 * @param limit - Maximum number of results (default: 10)
 * @returns Array of ambulances or empty array with message
 */
interface NearbyAmbulanceResult {
  ambulanceId: string;
  distance: number // in meters
  ambulanceData: IAmbulance | null;
}

/**
 * Find nearby ambulances with automatic radius failover
 * 1. Uses `geoSearchWith` to ensure we get distance data.
 * 2. Uses `COUNT: limit` to optimize Redis performance.
 * 3. Uses `SORT: "ASC"` to get nearest drivers first.
 */
const findNearbyAmbulances = async (
  longitude: number,
  latitude: number,
  limit: number = 10
): Promise<NearbyAmbulanceResult[]> => {
  // Define search radii in kilometers: 5 ‚Üí 10 ‚Üí 17 ‚Üí 30
  const searchRadii = [5, 10, 17, 30];

  console.log(`üîç Searching for ambulances near (${longitude}, ${latitude})`);

  for (const radius of searchRadii) {
    console.log(`üéØ Searching within ${radius}km radius...`);

    try {
      // use geoSearchWith to get objects { member, distance }
      const results = await redis.geoSearchWith(
        AMBULANCE_GEO_KEY,
        { longitude, latitude },
        { radius, unit: "km" },
        ["WITHDIST", "WITHCOORD"], // what info you want back
        {
          SORT: "ASC", // nearest first
          COUNT: limit,
        }
      );

      if (results && results.length > 0) {
        // Extract ambulance IDs from Redis results
        const ambulanceIds = results.map((result) => result.member);

        // Fetch full ambulance data from MongoDB
        const ambulances = await Ambulance.find({
          _id: { $in: ambulanceIds },
          status: "ready",
        }).select("-password -refreshToken");

        // Create map for quick lookup
        const ambulanceMap = new Map(
          ambulances.map((amb) => [amb._id.toString(), amb])
        );

        // Combine Redis distance with MongoDB data
        const nearbyAmbulances: NearbyAmbulanceResult[] = results
          .map((result) => ({
            ambulanceId: result.member,
            distance: result.distance ? Math.round(parseFloat(result.distance) * 1000) : 0, // Convert km string to meters
            ambulanceData: ambulanceMap.get(result.member) || null,
          }))
          .filter((result) => result.ambulanceData !== null);

        if (nearbyAmbulances.length > 0) {
          console.log(
            `‚úÖ Found ${nearbyAmbulances.length} ambulance(s) at ${radius}km`
          );
          return nearbyAmbulances;
        }
      }

      console.log(`‚ö†Ô∏è No ambulances at ${radius}km, expanding search...`);
    } catch (error) {
      console.error(`‚ùå Error searching at ${radius}km:`, error);
    }
  }

  console.log(`‚ùå No ambulances found within 30km`);
  return [];
};

/**
 * Get ambulance count in Redis (for debugging/monitoring)
 */
const getActiveAmbulanceCount = async (): Promise<number> => {
  try {
    const count = await redis.zCard(AMBULANCE_GEO_KEY);
    return count;
  } catch (error) {
    console.error("Error getting ambulance count:", error);
    return 0;
  }
};

/**
 * Get all ambulance IDs in Redis (for debugging)
 */
const getAllActiveAmbulanceIds = async (): Promise<string[]> => {
  try {
    const members = await redis.zRange(AMBULANCE_GEO_KEY, 0, -1);
    return members;
  } catch (error) {
    console.error("Error getting all ambulance IDs:", error);
    return [];
  }
};

export {
  syncAmbulancetoRedis,
  removeAmbulanceFromRedis,
  findNearbyAmbulances,
  getActiveAmbulanceCount,
  getAllActiveAmbulanceIds,
};



================================================================================
FILE: src/modules/hospital/controllers/hospital.controller.ts
================================================================================

import { asyncHandler } from "../../../shared/utils/AsyncHandler.js";
import { ApiError } from "../../../shared/utils/ApiError.js";
import { ApiResponse } from "../../../shared/utils/ApiResponce.js";
import { createHospitalSchema } from "../hospital.dto/hospital.dto.js";
import type { Request, Response } from "express";
import { Hospital } from "../model/hospital.model.js";
import { NODE_ENV } from "../../../config/env.js";
import { hospitalLoginSchema } from "../hospital.dto/hospital.dto.js";
import { findNearbyHospitals } from "../services/hospital.service.js";
import { SyncHospitalToRedis } from "../services/hospital.service.js";
import { removeHospitalFromRedis } from "../services/hospital.service.js";

/**
 * @description Register a new hospital
 * @route POST /api/v2/hospital/register
 * @access Public
 */

const registerHospital = asyncHandler(async (req: Request, res: Response) => {
  // Validate request body
  const validationResult = createHospitalSchema.safeParse(req.body);

  if (!validationResult.success) {
    throw new ApiError(400, "Validation failed", validationResult.error.issues);
  }

  const { name, email, location, phone, password, inventory, address } =
    validationResult.data;

  // Checking Hospital Existance
  const existingHospital = await Hospital.findOne({
    $or: [{ email: email }, { phone: phone }],
  });

  if (existingHospital) {
    throw new ApiError(
      409,
      existingHospital.email === email
        ? "Hospital with this email already exists"
        : "Hospital with this phone number already exists"
    );
  }

  // Create hospital
  const hospital = await Hospital.create({
    name,
    email,
    phone,
    password,
    address,
    location,
    inventory: inventory || {
      beds: { total: 0, available: 0 },
      bloodStock: {
        A_positive: 0,
        A_negative: 0,
        B_positive: 0,
        B_negative: 0,
        O_positive: 0,
        O_negative: 0,
        AB_positive: 0,
        AB_negative: 0,
      },
    },
  });

  const createdHospital = await Hospital.findById(hospital._id).select(
    "-password -refreshToken"
  );

  if (!createdHospital) {
    throw new ApiError(500, "Failed to create hospital");
  }

  //Generate Tokens
  const accessToken = hospital.GetAccessToken();
  const refreshToken = hospital.GetRefreshToken();

  createdHospital.refreshToken = refreshToken;
  await createdHospital.save({ validateBeforeSave: false });

  const cookieOptions = {
    httpOnly: true,
    secure: NODE_ENV === "production",
    sameSite: "strict" as const,
  };

  res
    .status(201)
    .cookie("accessToken", accessToken, {
      ...cookieOptions,
      maxAge: 15 * 60 * 1000,
    }) // 15 minutes
    .cookie("refreshToken", refreshToken, {
      ...cookieOptions,
      maxAge: 7 * 24 * 60 * 60 * 1000,
    }) // 7 days
    .json(
      new ApiResponse(
        201,
        {
          hospital: createdHospital,
          accessToken,
          refreshToken,
        },
        "Hospital registered successfully"
      )
    );
});

/**
 * @description Login hospital
 * @route POST /api/v2/hospital/login
 * @access Public
 */
const loginHospital = asyncHandler(async (req: Request, res: Response) => {
  // Validate request body
  const validationResult = hospitalLoginSchema.safeParse(req.body);

  if (!validationResult.success) {
    throw new ApiError(400, "Validation failed", validationResult.error.issues);
  }

  const { email, password } = validationResult.data;

  // Find hospital with password field
  const hospital = await Hospital.findOne({ email }).select("+password");

  if (!hospital) {
    throw new ApiError(401, "Invalid credentials");
  }

  // Verify password
  const isPasswordValid = await hospital.checkPassword(password);

  if (!isPasswordValid) {
    throw new ApiError(401, "Invalid credentials");
  }

  // Generate tokens
  const accessToken = hospital.GetAccessToken();
  const refreshToken = hospital.GetRefreshToken();

  // Save refresh token to database
  hospital.refreshToken = refreshToken;
  await hospital.save({ validateBeforeSave: false });

  // Fetch hospital without password and refreshToken
  const loggedInHospital = await Hospital.findById(hospital._id).select(
    "-password -refreshToken"
  );

  // Sync hospital location to Redis
  await SyncHospitalToRedis(hospital);
  // console.log(hospital);

  // Set cookies
  const cookieOptions = {
    httpOnly: true,
    secure: NODE_ENV === "production",
    sameSite: "strict" as const,
  };

  res
    .status(200)
    .cookie("accessToken", accessToken, {
      ...cookieOptions,
      maxAge: 15 * 60 * 1000,
    }) // 15 minutes
    .cookie("refreshToken", refreshToken, {
      ...cookieOptions,
      maxAge: 7 * 24 * 60 * 60 * 1000,
    }) // 7 days
    .json(
      new ApiResponse(
        200,
        {
          hospital: loggedInHospital,
          accessToken,
          refreshToken,
        },
        "Hospital logged in successfully"
      )
    );
});

/**
 * @description Logout hospital
 * @route POST /api/v2/hospital/logout
 * @access Private
 */
const logoutHospital = asyncHandler(async (req: Request, res: Response) => {
  const hospitalId = (req as any).hospital?._id;

  if (!hospitalId) {
    throw new ApiError(401, "Unauthorized");
  }

  // Clear refresh token from database
  await Hospital.findByIdAndUpdate(
    hospitalId,
    {
      $set: { refreshToken: null },
    },
    { new: true }
  );

  await removeHospitalFromRedis(hospitalId.toString());

  // Clear cookies
  const cookieOptions = {
    httpOnly: true,
    secure: NODE_ENV === "production",
    sameSite: "strict" as const,
  };

  res
    .status(200)
    .clearCookie("accessToken", cookieOptions)
    .clearCookie("refreshToken", cookieOptions)
    .json(new ApiResponse(200, {}, "Hospital logged out successfully"));
});

/**
 * @description Get current hospital profile
 * @route GET /api/v2/hospital/me
 * @access Private
 */
const getHospitalProfile = asyncHandler(async (req: Request, res: Response) => {
  const hospital = (req as any).hospital;

  if (!hospital) {
    throw new ApiError(401, "Unauthorized - Hospital not logged in");
  }

  res
    .status(200)
    .json(
      new ApiResponse(200, hospital, "Hospital profile fetched successfully")
    );
});

/**
 * @description Update hospital inventory (beds and blood stock)
 * @route PATCH /api/v2/hospital/inventory
 * @access Private
 */
const updateHospitalInventory = asyncHandler(
  async (req: Request, res: Response) => {
    const hospitalId = (req as any).hospital?._id;

    if (!hospitalId) {
      throw new ApiError(401, "Unauthorized");
    }

    const { beds, bloodStock } = req.body;

    // Build update object dynamically
    const updateData: any = {};

    if (beds) {
      if (beds.total !== undefined) {
        updateData["inventory.beds.total"] = beds.total;
      }
      if (beds.available !== undefined) {
        // Validate available doesn't exceed total
        const hospital = await Hospital.findById(hospitalId);
        const total = beds.total ?? hospital?.inventory.beds.total ?? 0;

        if (beds.available > total) {
          throw new ApiError(400, "Available beds cannot exceed total beds");
        }
        updateData["inventory.beds.available"] = beds.available;
      }
    }

    if (bloodStock) {
      Object.keys(bloodStock).forEach((key) => {
        if (bloodStock[key] !== undefined) {
          updateData[`inventory.bloodStock.${key}`] = bloodStock[key];
        }
      });
    }

    // Update hospital
    const hospital = await Hospital.findByIdAndUpdate(
      hospitalId,
      { $set: updateData },
      { new: true, runValidators: true }
    ).select("-password -refreshToken");

    if (!hospital) {
      throw new ApiError(404, "Hospital not found");
    }

    res
      .status(200)
      .json(
        new ApiResponse(
          200,
          hospital,
          "Hospital inventory updated successfully"
        )
      );
  }
);
/**
 * @description Update hospital location
 * @route PATCH /api/v2/hospital/location
 * @access Private
 */
const updateHospitalLocation = asyncHandler(
  async (req: Request, res: Response) => {
    const hospitalId = (req as any).hospital?._id;

    if (!hospitalId) {
      throw new ApiError(401, "Unauthorized");
    }

    const { location } = req.body;

    // Validate location format
    if (
      !location ||
      location.type !== "Point" ||
      !Array.isArray(location.coordinates) ||
      location.coordinates.length !== 2
    ) {
      throw new ApiError(
        400,
        "Invalid location format. Expected GeoJSON Point with [longitude, latitude]"
      );
    }

    // Update MongoDB
    const hospital = await Hospital.findByIdAndUpdate(
      hospitalId,
      { location },
      { new: true, runValidators: true }
    ).select("-password -refreshToken");

    if (!hospital) {
      throw new ApiError(404, "Hospital not found");
    }

    // Sync new location to Redis
    await SyncHospitalToRedis(hospital);

    res
      .status(200)
      .json(
        new ApiResponse(200, hospital, "Hospital location updated successfully")
      );
  }
);

const bloodTypeMapping: Record<string, string> = {
  "A+": "A_positive",
  "A-": "A_negative",
  "B+": "B_positive",
  "B-": "B_negative",
  "O+": "O_positive",
  "O-": "O_negative",
  "AB+": "AB_positive",
  "AB-": "AB_negative",
};

const getNearbyHospitals = asyncHandler(
  async (req: Request, res: Response) => {
    let { longitude, latitude, limit, bloodType, requireBeds } = req.query;

    // Validate required parameters
    if (!longitude || !latitude) {
      throw new ApiError(
        400,
        "Longitude and latitude are required query parameters"
      );
    }

    // Parse and validate values
    const lng = parseFloat(longitude as string);
    const lat = parseFloat(latitude as string);
    const maxResults = limit ? parseInt(limit as string, 10) : 10;

    // Validate ranges
    if (isNaN(lng) || lng < -180 || lng > 180) {
      throw new ApiError(
        400,
        "Invalid longitude. Must be between -180 and 180"
      );
    }

    if (isNaN(lat) || lat < -90 || lat > 90) {
      throw new ApiError(400, "Invalid latitude. Must be between -90 and 90");
    }

    if (isNaN(maxResults) || maxResults <= 0 || maxResults > 50) {
      throw new ApiError(400, "Invalid limit. Must be between 1 and 50");
    }

    // Build filters
    const filters: any = {};

    if (bloodType) {
      let rawBloodType = bloodType as string;

      // FIX 1: Handle URL encoding issue where '+' becomes ' '
      if (rawBloodType.includes(" ")) {
        rawBloodType = rawBloodType.replace(/ /g, "+");
      }

      // FIX 2: Map the symbol (e.g., "A+") to the DB field (e.g., "A_positive")
      const dbBloodField = bloodTypeMapping[rawBloodType];

      if (dbBloodField) {
        filters.bloodType = dbBloodField;
      } else {
        // Optional: If invalid blood type sent, you might want to ignore it or throw error
        console.warn(`Invalid blood type requested: ${rawBloodType}`);
      }
    }

    if (requireBeds === "true") {
      filters.requireBeds = true;
    }

    // Find nearby hospitals
    // Ensure findNearbyHospitals uses 'filters.bloodType' to check 'inventory.bloodStock[filters.bloodType]'
    const hospitals = await findNearbyHospitals(lng, lat, maxResults, filters);

    // Check if hospitals were found
    if (hospitals.length === 0) {
      return res.status(200).json(
        new ApiResponse(
          200,
          {
            count: 0,
            hospitals: [],
            message:
              "No hospitals found nearby matching your criteria. Please try expanding your search or contact emergency services.",
          },
          "No hospitals available within 50km"
        )
      );
    }

    // Return found hospitals
    res.status(200).json(
      new ApiResponse(
        200,
        {
          count: hospitals.length,
          hospitals: hospitals,
        },
        `Found ${hospitals.length} nearby hospital(s)`
      )
    );
  }
);

export {
  registerHospital,
  loginHospital,
  logoutHospital,
  getHospitalProfile,
  updateHospitalInventory,
  updateHospitalLocation,
  getNearbyHospitals
};



================================================================================
FILE: src/modules/hospital/hospital.dto/hospital.dto.ts
================================================================================

import { z } from "zod";

// Zod schema for hospital location (GeoJSON Point)
const locationSchema = z.object({
  type: z.literal("Point"),
  coordinates: z.tuple([
    z.number().min(-180).max(180), // longitude
    z.number().min(-90).max(90),   // latitude
  ]),
});

// Blood stock schema
const bloodStockSchema = z.object({
  A_positive: z.number().min(0).default(0),
  A_negative: z.number().min(0).default(0),
  B_positive: z.number().min(0).default(0),
  B_negative: z.number().min(0).default(0),
  O_positive: z.number().min(0).default(0),
  O_negative: z.number().min(0).default(0),
  AB_positive: z.number().min(0).default(0),
  AB_negative: z.number().min(0).default(0),
});

// Bed inventory schema
const bedInventorySchema = z.object({
  total: z.number().min(0).default(0),
  available: z.number().min(0).default(0),
});

// Hospital registration schema
export const createHospitalSchema = z.object({
  name: z.string().trim().min(1, "Hospital name is required"),
  email: z
    .string()
    .trim()
    .email("Invalid email format")
    .transform((val) => val.toLowerCase()),
  password: z.string().min(6, "Password must be at least 6 characters long"),
  phone: z
    .string()
    .trim()
    .min(10, "Phone number must be at least 10 digits")
    .regex(/^[0-9+()-\s]+$/, "Invalid phone number format"),
  address: z.string().trim().min(1, "Address is required"),
  location: locationSchema,
  inventory: z.object({
    beds: bedInventorySchema.optional().default({ total: 0, available: 0 }),
    bloodStock: bloodStockSchema.optional().default({
      A_positive: 0,
      A_negative: 0,
      B_positive: 0,
      B_negative: 0,
      O_positive: 0,
      O_negative: 0,
      AB_positive: 0,
      AB_negative: 0,
    }),
  }).optional(),
});

// Hospital login schema
export const hospitalLoginSchema = z.object({
  email: z
    .string()
    .trim()
    .email("Invalid email format")
    .transform((val) => val.toLowerCase()),
  password: z.string().min(1, "Password is required"),
});

// Update hospital inventory schema
export const updateInventorySchema = z.object({
  beds: bedInventorySchema.optional(),
  bloodStock: bloodStockSchema.partial().optional(),
});

// Update hospital location schema
export const updateHospitalLocationSchema = z.object({
  location: locationSchema,
});

// Nearby hospital query schema
export const nearbyHospitalQuerySchema = z.object({
  longitude: z.coerce.number().min(-180).max(180),
  latitude: z.coerce.number().min(-90).max(90),
  maxDistance: z.coerce.number().positive().default(10000), // in meters
  bloodType: z.enum(["A+", "A-", "B+", "B-", "O+", "O-", "AB+", "AB-"]).optional(),
  requireBeds: z.coerce.boolean().default(false),
});

// Type exports
export type CreateHospitalInput = z.infer<typeof createHospitalSchema>;
export type HospitalLoginInput = z.infer<typeof hospitalLoginSchema>;
export type UpdateInventoryInput = z.infer<typeof updateInventorySchema>;
export type UpdateHospitalLocationInput = z.infer<typeof updateHospitalLocationSchema>;
export type NearbyHospitalQuery = z.infer<typeof nearbyHospitalQuerySchema>;


================================================================================
FILE: src/modules/hospital/model/hospital.model.ts
================================================================================

import mongoose, { Document, Schema } from "mongoose";
import {
  generateAccessToken,
  generateRefreshToken,
  verifyPassword,
  hashPassword,
} from "../../../shared/utils/auth.util.js";

interface IBloodStock {
  A_positive: number;
  A_negative: number;
  B_positive: number;
  B_negative: number;
  O_positive: number;
  O_negative: number;
  AB_positive: number;
  AB_negative: number;
}

interface IBedInventory {
  total: number;
  available: number;
}

export interface IHospital extends Document {
  name: string;
  email: string;
  password?: string;
  phone: string;
  address: string;
  location: {
    type: "Point";
    coordinates: [number, number]; // [lng, lat]
  };
  inventory: {
    beds: IBedInventory;
    bloodStock: IBloodStock;
  };
  refreshToken?: string | null;

  // Methods
  checkPassword(password: string): Promise<boolean>;
  GetAccessToken(): string;
  GetRefreshToken(): string;
}

const HospitalSchema = new Schema<IHospital>(
  {
    name: {
      type: String,
      required: true,
      trim: true,
    },
    email: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      lowercase: true,
    },
    password: {
      type: String,
      required: true,
      minlength: 6,
      select: false,
    },
    phone: {
      type: String,
      required: true,
      trim: true,
    },
    address: {
      type: String,
      required: true,
    },
    location: {
      type: {
        type: String,
        enum: ["Point"],
        required: true,
        default: "Point",
      },
      coordinates: {
        type: [Number],
        required: true,
      },
    },
    inventory: {
      beds: {
        total: { type: Number, default: 0 },
        available: { type: Number, default: 0 },
      },
      bloodStock: {
        A_positive: { type: Number, default: 0 },
        A_negative: { type: Number, default: 0 },
        B_positive: { type: Number, default: 0 },
        B_negative: { type: Number, default: 0 },
        O_positive: { type: Number, default: 0 },
        O_negative: { type: Number, default: 0 },
        AB_positive: { type: Number, default: 0 },
        AB_negative: { type: Number, default: 0 },
      },
    },
    refreshToken: {
      type: String,
      default: null,
      select: false,
    },
  },
  { timestamps: true }
);

HospitalSchema.index({ location: "2dsphere" });

HospitalSchema.pre<IHospital>(
  "save",
  async function (this: IHospital & Document) {
    if (!this.isModified("password")) return;
    this.password = await hashPassword(this.password as string);
  }
);

HospitalSchema.methods.checkPassword = async function (
  this: IHospital,
  enteredPassword: string
): Promise<boolean> {
  if (!this.password) return false;
  return await verifyPassword(enteredPassword, this.password);
};

HospitalSchema.methods.GetAccessToken = function (this: IHospital): string {
  // Added role: 'hospital' to payload for easy identification
  return generateAccessToken({ id: this._id.toHexString(), role: "hospital" });
};

HospitalSchema.methods.GetRefreshToken = function (this: IHospital): string {
  return generateRefreshToken({ id: this._id.toHexString(), role: "hospital" });
};

export const Hospital = mongoose.model<IHospital>("Hospital", HospitalSchema);



================================================================================
FILE: src/modules/hospital/routes/hospital.routes.ts
================================================================================

import { Router } from "express";
import { z } from "zod";
import { validate } from "../../../shared/middlewares/validate.middleware.js";
import { verifyHospitalJWT } from "../../../shared/middlewares/auth.middleware.js";
import {
  createHospitalSchema,
  hospitalLoginSchema,
  updateInventorySchema,
  updateHospitalLocationSchema,
} from "../hospital.dto/hospital.dto.js";
import {
  registerHospital,
  loginHospital,
  logoutHospital,
  getHospitalProfile,
  updateHospitalInventory,
  updateHospitalLocation,
  getNearbyHospitals,
} from "../controllers/hospital.controller.js";

const router = Router();

// ============================================
// PUBLIC ROUTES
// ============================================

/**
 * @route   POST /api/v2/hospital/register
 * @desc    Register a new hospital
 * @access  Public
 */
router.post(
  "/register",
  validate(z.object({ body: createHospitalSchema })),
  registerHospital
);

/**
 * @route   POST /api/v2/hospital/login
 * @desc    Login hospital with email
 * @access  Public
 */
router.post(
  "/login",
  validate(z.object({ body: hospitalLoginSchema })),
  loginHospital
);

/**
 * @route   GET /api/v2/hospital/nearby
 * @desc    Find nearby hospitals based on user location
 * @access  Public
 * @query   longitude, latitude, limit (optional), bloodType (optional), requireBeds (optional)
 */
router.get("/nearby", getNearbyHospitals);


// ============================================
// PROTECTED ROUTES (Hospital Authentication Required)
// ============================================

/**
 * @route   POST /api/v2/hospital/logout
 * @desc    Logout hospital and clear tokens
 * @access  Private
 */
router.post("/logout", verifyHospitalJWT, logoutHospital);

/**
 * @route   GET /api/v2/hospital/me
 * @desc    Get current hospital profile
 * @access  Private
 */
router.get("/me", verifyHospitalJWT, getHospitalProfile);

/**
 * @route   PATCH /api/v2/hospital/inventory
 * @desc    Update hospital inventory (beds and blood stock)
 * @access  Private
 */
router.patch(
  "/inventory",
  verifyHospitalJWT,
  validate(z.object({ body: updateInventorySchema })),
  updateHospitalInventory
);

/**
 * @route   PATCH /api/v2/hospital/location
 * @desc    Update hospital location
 * @access  Private
 */
router.patch(
  "/location",
  verifyHospitalJWT,
  validate(z.object({ body: updateHospitalLocationSchema })),
  updateHospitalLocation
);

export const hospitalRoutes: ReturnType<typeof Router> = router;


================================================================================
FILE: src/modules/hospital/services/hospital.service.ts
================================================================================

import redis from "../../../config/redis.js";
import { Hospital, type IHospital } from "../model/hospital.model.js";
import type { Types } from "mongoose";

const HOSPITAL_GEO_KEY = "hospital_locations";

export interface IHospitalLocation {
  type: "Point";
  coordinates: [number, number]; // [longitude, latitude]
  address?: string;
}

export interface IHospitalSyncPayload {
  _id: Types.ObjectId | string;
  location: IHospitalLocation;
}

/**
 * Syncs the hospital location and state with Redis.
 */
const SyncHospitalToRedis = async (
  hospital: IHospitalSyncPayload | IHospital
): Promise<void> => {
  const { _id, location } = hospital;
  const hospital_id = _id.toString();

  try {
    // Check if location and coordinates exist
    if (!location || !location.coordinates) {
      console.warn(`Redis: No location data for hospital ${hospital_id}`);
      return;
    }

    const [lng, lat] = location.coordinates;

    // Validate coordinates before sending to Redis
    if (typeof lng === "number" && typeof lat === "number") {
      // GEOADD key longitude latitude member
      await redis.geoAdd(HOSPITAL_GEO_KEY, {
        member: hospital_id,
        longitude: lng,
        latitude: lat,
      });
      console.log(`Redis: Added hospital ${hospital_id} to location index`);
    } else {
      console.warn(`Redis: Invalid coordinates for hospital ${hospital_id}`);
    }
  } catch (error) {
    console.error(`Redis Sync Error for hospital ${hospital_id}:`, error);
  }
};

/**
 * Explicitly remove hospital from Redis (used on deletion/deactivation)
 */
const removeHospitalFromRedis = async (hospitalId: string): Promise<void> => {
  try {
    await redis.zRem(HOSPITAL_GEO_KEY, hospitalId);
    console.log(`Redis: Removed hospital ${hospitalId} from location index`);
  } catch (error) {
    console.error(`Redis Removal Error for hospital ${hospitalId}:`, error);
  }
};

interface NearbyHospitalResult {
  hospitalId: string;
  distance: number; // in meters
  hospitalData: IHospital | null;
}

/**
 * Find nearby hospitals with automatic radius failover
 * Searches at: 5km ‚Üí 10km ‚Üí 17km ‚Üí 30km
 * @param longitude - User's longitude
 * @param latitude - User's latitude
 * @param limit - Maximum number of results (default: 10)
 * @param filters - Optional filters for blood type and beds
 * @returns Array of hospitals or empty array
 */
const findNearbyHospitals = async (
  longitude: number,
  latitude: number,
  limit: number = 10,
  filters?: {
    bloodType?: string;
    requireBeds?: boolean;
  }
): Promise<NearbyHospitalResult[]> => {
  // Define search radii in kilometers: 5 ‚Üí 10 ‚Üí 17 ‚Üí 30
  const searchRadii = [5, 10, 17, 30];
  
  console.log(`üîç Searching for hospitals near (${longitude}, ${latitude})`);

  for (const radius of searchRadii) {
    console.log(`üéØ Searching within ${radius}km radius...`);

    try {
      // Use geoSearchWith to get objects { member, distance }
      const results = await redis.geoSearchWith(
        HOSPITAL_GEO_KEY,
        { longitude, latitude },
        { radius, unit: "km" },
        ["WITHDIST", "WITHCOORD"], // what info you want back
        {
          SORT: "ASC", // nearest first
          COUNT: limit * 2, // Get more to account for filtering
        }
      );

      if (results && results.length > 0) {
        // Extract hospital IDs from Redis results
        const hospitalIds = results.map((result) => result.member);

        // Build MongoDB query
        const query: any = { 
          _id: { $in: hospitalIds } 
        };

        // Apply filters if provided
        if (filters?.bloodType) {
          const bloodKey = filters.bloodType
            .replace("+", "_positive")
            .replace("-", "_negative");
          query[`inventory.bloodStock.${bloodKey}`] = { $gt: 0 };
        }

        if (filters?.requireBeds) {
          query["inventory.beds.available"] = { $gt: 0 };
        }

        // Fetch full hospital data from MongoDB
        const hospitals = await Hospital.find(query).select(
          "-password -refreshToken"
        );

        // Create map for quick lookup
        const hospitalMap = new Map(
          hospitals.map((hospital) => [hospital._id.toString(), hospital])
        );

        // Combine Redis distance with MongoDB data
        const nearbyHospitals: NearbyHospitalResult[] = results
          .map((result) => ({
            hospitalId: result.member,
            distance: result.distance
              ? Math.round(parseFloat(result.distance) * 1000) // Convert km string to meters
              : 0,
            hospitalData: hospitalMap.get(result.member) || null,
          }))
          .filter((result) => result.hospitalData !== null)
          .slice(0, limit); // Apply limit after filtering

        if (nearbyHospitals.length > 0) {
          console.log(
            `‚úÖ Found ${nearbyHospitals.length} hospital(s) at ${radius}km`
          );
          return nearbyHospitals;
        }
      }

      console.log(`‚ö†Ô∏è No hospitals found at ${radius}km, expanding search...`);
    } catch (error) {
      console.error(`‚ùå Error searching at ${radius}km:`, error);
    }
  }

  console.log(`‚ùå No hospitals found within 30km`);
  return [];
};

/**
 * Get hospital count in Redis (for monitoring)
 */
const getActiveHospitalCount = async (): Promise<number> => {
  try {
    const count = await redis.zCard(HOSPITAL_GEO_KEY);
    return count;
  } catch (error) {
    console.error("Error getting hospital count:", error);
    return 0;
  }
};

/**
 * Get all hospital IDs in Redis (for debugging)
 */
const getAllActiveHospitalIds = async (): Promise<string[]> => {
  try {
    const members = await redis.zRange(HOSPITAL_GEO_KEY, 0, -1);
    return members;
  } catch (error) {
    console.error("Error getting all hospital IDs:", error);
    return [];
  }
};

export {
  SyncHospitalToRedis,
  removeHospitalFromRedis,
  findNearbyHospitals,
  getActiveHospitalCount,
  getAllActiveHospitalIds,
};


================================================================================
FILE: src/modules/trip/controllers/trip.controller.ts
================================================================================

// src/modules/trip/controllers/trip.controller.ts

import type { Request, Response } from "express";
import { asyncHandler } from "../../../shared/utils/AsyncHandler.js";
import { ApiError } from "../../../shared/utils/ApiError.js";
import { ApiResponse } from "../../../shared/utils/ApiResponce.js";
import {
  createTripSchema,
  updateTripStatusSchema,
  assignAmbulanceSchema,
} from "../trip.dto/trip.dto.js";
import {
  createTripRequest,
  updateTripStatus,
  assignAmbulanceToTrip,
  cancelTrip,
  getTripDetails,
  getUserTripHistory,
  getActiveTrip,
} from "../services/trip.service.js";
import { Trip } from "../model/trip.model.js";

/**
 * @description Create a new trip request
 * @route POST /api/v2/trip/request
 * @access Private (User)
 */
const requestAmbulance = asyncHandler(
  async (req: Request, res: Response) => {
    const userId = req.user?._id;
    if (!userId) {
      throw new ApiError(401, "Unauthorized");
    }

    // Validate request body
    const validationResult = createTripSchema.safeParse(req.body);
    if (!validationResult.success) {
      throw new ApiError(
        400,
        "Validation failed",
        validationResult.error.issues
      );
    }

    const {
      pickupAddress,
      pickupCoordinates,
      destinationHospitalId,
      bloodType,
      requireBeds,
    } = validationResult.data;

    // Create trip
    const trip = await createTripRequest({
      userId: userId.toString(),
      ...(pickupAddress && { pickupAddress }),
      pickupCoordinates,
      ...(destinationHospitalId && { destinationHospitalId }),
      ...(bloodType && { bloodType }),
      ...(requireBeds && { requireBeds }),
    });

    res
      .status(201)
      .json(
        new ApiResponse(
          201,
          trip,
          "Ambulance request created successfully. Searching for available ambulances..."
        )
      );
  }
);

/**
 * @description Get current active trip for logged-in user
 * @route GET /api/v2/trip/active
 * @access Private (User)
 */
const getMyActiveTrip = asyncHandler(
  async (req: Request, res: Response) => {
    const userId = req.user?._id;
    if (!userId) {
      throw new ApiError(401, "Unauthorized");
    }

    const trip = await getActiveTrip(userId.toString());

    if (!trip) {
      return res
        .status(200)
        .json(new ApiResponse(200, null, "No active trip found"));
    }

    res
      .status(200)
      .json(new ApiResponse(200, trip, "Active trip retrieved successfully"));
  }
);

/**
 * @description Get trip details by ID
 * @route GET /api/v2/trip/:tripId
 * @access Private (User/Ambulance/Admin)
 */
const getTripById = asyncHandler(
  async (req: Request, res: Response) => {
    const { tripId } = req.params;

    if (!tripId) {
      throw new ApiError(400, "Trip ID is required");
    }

    const trip = await getTripDetails(tripId);

    // Authorization check
    const userId = req.user?._id || req.ambulance?._id || req.admin?._id;
    if (
      !req.admin &&
      trip.userId._id.toString() !== userId?.toString() &&
      trip.ambulanceId?._id?.toString() !== userId?.toString()
    ) {
      throw new ApiError(403, "Forbidden - Access denied");
    }

    res
      .status(200)
      .json(new ApiResponse(200, trip, "Trip details retrieved successfully"));
  }
);


/**
 * @description Get user's trip history
 * @route GET /api/v2/trip/history
 * @access Private (User)
 */
const getMyTripHistory = asyncHandler(
  async (req: Request, res: Response) => {
    const userId = req.user?._id;
    if (!userId) {
      throw new ApiError(401, "Unauthorized");
    }

    const limit = req.query.limit
      ? parseInt(req.query.limit as string, 10)
      : 10;

    const trips = await getUserTripHistory(userId.toString(), limit);

    res
      .status(200)
      .json(
        new ApiResponse(
          200,
          { count: trips.length, trips },
          "Trip history retrieved successfully"
        )
      );
  }
);

/**
 * @description Ambulance accepts a trip
 * @route POST /api/v2/trip/:tripId/accept
 * @access Private (Ambulance)
 */
const acceptTrip = asyncHandler(
  async (req: Request, res: Response) => {
    const ambulanceId = req.ambulance?._id;
    if (!ambulanceId) {
      throw new ApiError(401, "Unauthorized - Ambulance not logged in");
    }

    const { tripId } = req.params;
    if (!tripId) {
      throw new ApiError(400, "Trip ID is required");
    }

    const trip = await assignAmbulanceToTrip(
      tripId,
      ambulanceId.toString()
    );

    res
      .status(200)
      .json(new ApiResponse(200, trip, "Trip accepted successfully"));
  }
);

/**
 * @description Update trip status (Ambulance only)
 * @route PATCH /api/v2/trip/:tripId/status
 * @access Private (Ambulance)
 */
const updateTripStatusByAmbulance = asyncHandler(
  async (req: Request, res: Response) => {
    const ambulanceId = req.ambulance?._id;
    if (!ambulanceId) {
      throw new ApiError(401, "Unauthorized - Ambulance not logged in");
    }

    const { tripId } = req.params;
    if (!tripId) {
      throw new ApiError(400, "Trip ID is required");
    }

    // Validate request body
    const validationResult = updateTripStatusSchema.safeParse(req.body);
    if (!validationResult.success) {
      throw new ApiError(
        400,
        "Validation failed",
        validationResult.error.issues
      );
    }

    const { status, location } = validationResult.data;

    const trip = await updateTripStatus({
      tripId,
      status,
      ...(location && { location }),
      updatedBy: `ambulance:${ambulanceId.toString()}`,
    });

    res
      .status(200)
      .json(
        new ApiResponse(200, trip, "Trip status updated successfully")
      );
  }
);

/**
 * @description Cancel trip (User or Ambulance)
 * @route POST /api/v2/trip/:tripId/cancel
 * @access Private (User/Ambulance)
 */
const cancelTripRequest = asyncHandler(
  async (req: Request, res: Response) => {
    const { tripId } = req.params;
    if (!tripId) {
      throw new ApiError(400, "Trip ID is required");
    }

    const userId = req.user?._id;
    const ambulanceId = req.ambulance?._id;

    if (!userId && !ambulanceId) {
      throw new ApiError(401, "Unauthorized");
    }

    const cancelledBy = userId
      ? `user:${userId.toString()}`
      : `ambulance:${ambulanceId!.toString()}`;

    const trip = await cancelTrip(tripId, cancelledBy);

    res
      .status(200)
      .json(new ApiResponse(200, trip, "Trip cancelled successfully"));
  }
);

/**
 * @description Get all trips (Admin only)
 * @route GET /api/v2/trip/all
 * @access Private (Admin)
 */
const getAllTrips = asyncHandler(
  async (req: Request, res: Response) => {
    const adminId = req.admin?._id;
    if (!adminId) {
      throw new ApiError(403, "Forbidden - Admin access required");
    }

    const { status, limit = 50, page = 1 } = req.query;

    const query: any = {};
    if (status) {
      query.status = status;
    }

    const skip = (Number(page) - 1) * Number(limit);

    const [trips, total] = await Promise.all([
      (Trip as any)
        .find(query)
        .sort({ createdAt: -1 })
        .limit(Number(limit))
        .skip(skip)
        .populate("userId", "name phone email")
        .populate("ambulanceId", "driverName vehicleNumber")
        .populate("destinationHospitalId", "name address")
        .lean(),
      (Trip as any).countDocuments(query),
    ]);

    res.status(200).json(
      new ApiResponse(
        200,
        {
          trips,
          pagination: {
            total,
            page: Number(page),
            limit: Number(limit),
            pages: Math.ceil(total / Number(limit)),
          },
        },
        "All trips retrieved successfully"
      )
    );
  }
);

export {
    getAllTrips,
    getActiveTrip,
    cancelTripRequest,
    acceptTrip,
    getMyTripHistory,
    updateTripStatusByAmbulance,
    getTripById,
    getMyActiveTrip,
    requestAmbulance
}


================================================================================
FILE: src/modules/trip/model/trip.model.ts
================================================================================

import mongoose, { Document, Schema } from "mongoose";
import { string } from "zod";

export type TripStatus =
  | "SEARCHING" // Looking for driver
  | "ACCEPTED" // Driver accepted (was 'ASSIGNED')
  | "ARRIVED_PICKUP" // Driver reached patient
  | "EN_ROUTE_HOSPITAL" // Driving to hospital
  | "ARRIVED_HOSPITAL" // Reached hospital gate
  | "COMPLETED" // Handover done
  | "CANCELLED";

export interface ITripTimeline {
  status: TripStatus;
  timestamp: Date;
  location?: [number, number]; // Coordinates where this happened
  updatedBy?: string; // "system", "driver:ID", "user:ID"
}

export interface IPatientSnapshot {
  userId: string;
  name: string;
  phone: string;
  medicalHistory?: string;
  bloodGroup: string;
}

export interface ITrip extends Document {
  userId: mongoose.Types.ObjectId;

  ambulanceId?: mongoose.Types.ObjectId | null | string;
  destinationHospitalId?: mongoose.Types.ObjectId | null | string;

  status: TripStatus;

  pickup: {
    address?: string;
    coordinates: [number, number]; // [lng, lat]
  };

  dropoff?: {
    address?: string;
    coordinates?: [number, number];
  };

  //  Specific Time Fields for easier Analytics
  acceptedAt?: Date;
  arrivedAtPickup?: Date;
  arrivedAtHospital?: Date;
  completedAt?: Date;

  distance?: number;
  cost?: number;

  patientSnapshot: IPatientSnapshot;
  timeline: ITripTimeline[];

  createdAt: Date;
  updatedAt: Date;
}

const TripSchema = new Schema<ITrip>(
  {
    userId: {
      type: Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    ambulanceId: {
      type: Schema.Types.ObjectId,
      ref: "Ambulance",
      default: null,
    },
    destinationHospitalId: {
      type: Schema.Types.ObjectId,
      ref: "Hospital",
      default: null,
    },

    status: {
      type: String,
      enum: [
        "SEARCHING",
        "ACCEPTED",
        "ARRIVED_PICKUP",
        "EN_ROUTE_HOSPITAL",
        "ARRIVED_HOSPITAL",
        "COMPLETED",
        "CANCELLED",
      ],
      default: "SEARCHING",
      index: true,
    },

    // Specific Timestamp Fields (Optimized for Reports/Analytics)
    acceptedAt: { type: Date },
    arrivedAtPickup: { type: Date },
    arrivedAtHospital: { type: Date },
    completedAt: { type: Date },

    pickup: {
      address: { type: String },
      coordinates: {
        type: [Number],
        required: true,
        index: "2dsphere",
      },
    },

    dropoff: {
      address: { type: String },
      coordinates: { type: [Number] },
    },

    patientSnapshot: {
      userId: { type: String, required: true },
      name: { type: String, required: true },
      phone: { type: String, required: true },
      medicalHistory: { type: String, default: "" },
      bloodGroup: { type: String, required: true },
    },

    // Audit Trail
    timeline: [
      {
        status: { type: String, required: true },
        timestamp: { type: Date, default: Date.now },
        location: { type: [Number] },
        updatedBy: { type: String },
      },
    ],
  },
  {
    timestamps: true,
  }
);

export const Trip = mongoose.model<ITrip>("Trip", TripSchema);


================================================================================
FILE: src/modules/trip/routes/trip.routes.ts
================================================================================

// src/modules/trip/routes/trip.routes.ts

import { Router } from "express";
import { z } from "zod";
import { validate } from "../../../shared/middlewares/validate.middleware.js";
import {
  verifyUserJWT,
  verifyAmbulanceJWT,
  verifyJWT,
  verifyAdminJWT,
} from "../../../shared/middlewares/auth.middleware.js";
import {
  createTripSchema,
  updateTripStatusSchema,
} from "../trip.dto/trip.dto.js";
import {
  requestAmbulance,
  getMyActiveTrip,
  getTripById,
  getMyTripHistory,
  acceptTrip,
  updateTripStatusByAmbulance,
  cancelTripRequest,
  getAllTrips,
} from "../controllers/trip.controller.js";

const router = Router();

// ============================================
// USER ROUTES
// ============================================

/**
 * @route   POST /api/v2/trip/request
 * @desc    Request an ambulance
 * @access  Private (User)
 */
router.post(
  "/request",
  verifyUserJWT,
  validate(z.object({ body: createTripSchema })),
  requestAmbulance
);

/**
 * @route   GET /api/v2/trip/active
 * @desc    Get current active trip
 * @access  Private (User)
 */
router.get("/active", verifyUserJWT, getMyActiveTrip);

/**
 * @route   GET /api/v2/trip/history
 * @desc    Get trip history
 * @access  Private (User)
 */
router.get("/history", verifyUserJWT, getMyTripHistory);

/**
 * @route   POST /api/v2/trip/:tripId/cancel
 * @desc    Cancel a trip
 * @access  Private (User/Ambulance)
 */
router.post("/cancel/:tripId", verifyJWT, cancelTripRequest);

// ============================================
// AMBULANCE ROUTES
// ============================================

/**
 * @route   POST /api/v2/trip/:tripId/accept
 * @desc    Accept a trip request
 * @access  Private (Ambulance)
 */
router.post("/:tripId/accept", verifyAmbulanceJWT, acceptTrip);

/**
 * @route   PATCH /api/v2/trip/:tripId/status
 * @desc    Update trip status
 * @access  Private (Ambulance)
 */
router.patch(
  "/:tripId/status",
  verifyAmbulanceJWT,
  validate(z.object({ body: updateTripStatusSchema })),
  updateTripStatusByAmbulance
);

// ============================================
// SHARED ROUTES (User/Ambulance/Admin)
// ============================================

/**
 * @route   GET /api/v2/trip/:tripId
 * @desc    Get trip details by ID
 * @access  Private (User/Ambulance/Admin)
 */
router.get("/:tripId", verifyJWT, getTripById);

// ============================================
// ADMIN ROUTES
// ============================================

/**
 * @route   GET /api/v2/trip/all
 * @desc    Get all trips with filters
 * @access  Private (Admin)
 */
router.get("/admin/all", verifyAdminJWT, getAllTrips);

export const tripRoutes: ReturnType<typeof Router> = router;


================================================================================
FILE: src/modules/trip/services/trip.service.ts
================================================================================

import { Trip } from "../model/trip.model.js";
import type { ITrip, TripStatus } from "../model/trip.model.js";
import { User } from "../../user/model/user.model.js";
import { Hospital } from "../../hospital/model/hospital.model.js";
import { ApiError } from "../../../shared/utils/ApiError.js";
import { Ambulance } from "../../ambulance/model/ambulance.model.js";
import { findNearbyAmbulances } from "../../ambulance/services/ambulance.service.js";
import { findNearbyHospitals } from "../../hospital/services/hospital.service.js";
import type { Types } from "mongoose";
import mongoose from "mongoose";

interface CreateTripInput {
  userId: string;
  pickupAddress?: string;
  pickupCoordinates: [number, number];
  destinationHospitalId?: string;
  bloodType?: string;
  requireBeds?: boolean;
}

interface UpdateTripStatusInput {
  tripId: string;
  status: TripStatus;
  ambulanceId?: string;
  location?: [number, number];
  updatedBy?: string;
}

/**
 * Create a new trip request
 * 1. Validate user exists and has complete profile
 * 2. Find nearby ambulances (with failover)
 * 3. Optionally find suitable hospital
 * 4. Create trip with SEARCHING status
 */
const createTripRequest = async (
  input: CreateTripInput & { userId: string } // Ensure userId is passed if not in DTO body
): Promise<ITrip> => {
  const {
    userId,
    pickupAddress,
    pickupCoordinates,
    destinationHospitalId,
    bloodType,
    requireBeds,
  } = input;

  // 1. Validate user exists and fetch profile
  const user = await User.findById(userId).select("-password -refreshToken");
  if (!user) {
    throw new ApiError(404, "User not found");
  }

  // 2. Check if user already has an active trip
  const existingTrip = await Trip.findOne({
    userId,
    status: {
      $in: [
        "SEARCHING",
        "ACCEPTED",
        "ARRIVED_PICKUP",
        "EN_ROUTE_HOSPITAL",
        "ARRIVED_HOSPITAL",
      ],
    },
  });

  if (existingTrip) {
    throw new ApiError(
      409,
      "You already have an active trip. Please complete or cancel it first."
    );
  }

  // 3. Find nearby ambulances
  const [lng, lat] = pickupCoordinates;
  const nearbyAmbulances = await findNearbyAmbulances(lng, lat, 5);

  if (nearbyAmbulances.length === 0) {
    // Log emergency - could trigger admin notification
    console.warn(
      `‚ö†Ô∏è EMERGENCY: No ambulances found for user ${userId} at [${lng}, ${lat}]`
    );
  }

  // 4. Find suitable hospital if needed
  let hospital: any = null;

  // Only search for hospital if destinationHospitalId is provided AND is a valid ObjectId
  if (
    destinationHospitalId &&
    destinationHospitalId.trim() !== "" &&
    mongoose.Types.ObjectId.isValid(destinationHospitalId)
  ) {
    hospital = await Hospital.findById(destinationHospitalId).select(
      "-password -refreshToken"
    );
    if (!hospital) {
      throw new ApiError(404, "Specified hospital not found");
    }
  }

  // If no hospital selected yet (either not provided or invalid ID ignored), try auto-finding
  if (!hospital && (bloodType || requireBeds)) {
    // Auto-find nearest suitable hospital based on requirements
    const filters: any = {};
    if (bloodType) {
      // Map blood type to database field format
      const bloodTypeMapping: Record<string, string> = {
        "A+": "A_positive",
        "A-": "A_negative",
        "B+": "B_positive",
        "B-": "B_negative",
        "O+": "O_positive",
        "O-": "O_negative",
        "AB+": "AB_positive",
        "AB-": "AB_negative",
      };
      filters.bloodType = bloodTypeMapping[bloodType] || bloodType;
    }
    if (requireBeds) filters.requireBeds = true;

    const nearbyHospitals = await findNearbyHospitals(lng, lat, 1, filters);
    if (nearbyHospitals.length > 0) {
      hospital = nearbyHospitals[0]?.hospitalData;
    }
  }

  // 5. Create trip with patient snapshot
  // FIX: Use 'new Trip()' + 'save()' instead of 'Trip.create()' to avoid returning an array type
  const trip = new Trip({
    userId: user._id,
    status: "SEARCHING",
    pickup: {
      ...(pickupAddress && { address: pickupAddress }),
      coordinates: pickupCoordinates,
    },
    ...(hospital && {
      dropoff: {
        address: hospital.address,
        coordinates: hospital.location.coordinates,
      },
      destinationHospitalId: hospital._id,
    }),
    patientSnapshot: {
      userId: user._id.toString(),
      name: user.name,
      phone: user.phone,
      bloodGroup: user.bloodGroup,
      medicalHistory: user.medicalHistory || "",
    },
    timeline: [
      {
        status: "SEARCHING",
        timestamp: new Date(),
        location: pickupCoordinates,
        updatedBy: `user:${userId}`,
      },
    ],
  });

  await trip.save();

  return trip;
};


/**
 * Validate status transition logic
 */
function validateStatusTransition(
  currentStatus: TripStatus,
  newStatus: TripStatus
): void {
  const validTransitions: Record<TripStatus, TripStatus[]> = {
    SEARCHING: ["ACCEPTED", "CANCELLED"],
    ACCEPTED: ["ARRIVED_PICKUP", "CANCELLED"],
    ARRIVED_PICKUP: ["EN_ROUTE_HOSPITAL", "CANCELLED"],
    EN_ROUTE_HOSPITAL: ["ARRIVED_HOSPITAL", "CANCELLED"],
    ARRIVED_HOSPITAL: ["COMPLETED", "CANCELLED"],
    COMPLETED: [],
    CANCELLED: [],
  };

  if (!validTransitions[currentStatus].includes(newStatus)) {
    throw new ApiError(
      400,
      `Invalid status transition from ${currentStatus} to ${newStatus}`
    );
  }
}
/**
 * Update trip status with timeline tracking
 */
const updateTripStatus = async (
  input: UpdateTripStatusInput
): Promise<ITrip> => {
  const { tripId, status, ambulanceId, location, updatedBy } = input;

  const trip = await Trip.findByIdAndUpdate(
    tripId,
    {},
    { new: true }
  );
  if (!trip) {
    throw new ApiError(404, "Trip not found");
  }

  // Validate status transition
  validateStatusTransition(trip.status, status);

  // Update specific timestamp fields for analytics
  const updateData: any = { status };

  switch (status) {
    case "ACCEPTED":
      if (!ambulanceId) {
        throw new ApiError(400, "Ambulance ID required for ACCEPTED status");
      }
      updateData.ambulanceId = ambulanceId;
      updateData.acceptedAt = new Date();
      break;
    case "ARRIVED_PICKUP":
      updateData.arrivedAtPickup = new Date();
      break;
    case "ARRIVED_HOSPITAL":
      updateData.arrivedAtHospital = new Date();
      break;
    case "COMPLETED":
      updateData.completedAt = new Date();
      break;
  }

  // Add to timeline
  trip.timeline.push({
    status,
    timestamp: new Date(),
    ...(location && { location }),
    ...(updatedBy && { updatedBy }),
  });

  // Update trip
  Object.assign(trip, updateData);
  trip.timeline = trip.timeline; // Ensure timeline is marked as modified
  const updatedTrip = await trip.save();

  return updatedTrip as ITrip;
};

/**
 * Assign ambulance to trip
 */
const assignAmbulanceToTrip = async (
  tripId: string,
  ambulanceId: string
): Promise<ITrip> => {
  const trip = await Trip.findById(tripId);
  if (!trip) {
    throw new ApiError(404, "Trip not found");
  }

  if (trip.status !== "SEARCHING") {
    throw new ApiError(
      400,
      "Trip is not in SEARCHING state. Cannot assign ambulance."
    );
  }

  const ambulance = await Ambulance.findById(ambulanceId);
  if (!ambulance) {
    throw new ApiError(404, "Ambulance not found");
  }

  if (ambulance.status !== "ready") {
    throw new ApiError(400, "Ambulance is not available");
  }

  // Update trip
  return await updateTripStatus({
    tripId,
    status: "ACCEPTED",
    ambulanceId,
    location: ambulance.location.coordinates,
    updatedBy: `ambulance:${ambulanceId}`,
  });
};

/**
 * Cancel trip
 */
const cancelTrip = async (
  tripId: string,
  cancelledBy: string
): Promise<ITrip> => {
  const trip = await Trip.findById(tripId);
  if (!trip) {
    throw new ApiError(404, "Trip not found");
  }

  if (["COMPLETED", "CANCELLED"].includes(trip.status)) {
    throw new ApiError(400, "Trip is already completed or cancelled");
  }

  trip.status = "CANCELLED";
  trip.timeline.push({
    status: "CANCELLED",
    timestamp: new Date(),
    updatedBy: cancelledBy,
  });

  await trip.save();

  // If ambulance was assigned, free it up
  if (trip.ambulanceId) {
    await Ambulance.findByIdAndUpdate(trip.ambulanceId, { status: "ready" });
  }

  return trip;
};

/**
 * Get trip details with populated references
 */
const getTripDetails = async (tripId: string): Promise<any> => {
  const trip = await Trip.findById(tripId)
    .populate("userId", "-password -refreshToken")
    .populate("ambulanceId", "-password -refreshToken")
    .populate("destinationHospitalId", "-password -refreshToken")
    .lean();

  if (!trip) {
    throw new ApiError(404, "Trip not found");
  }

  return trip;
};

/**
 * Get user's trip history
 */
const getUserTripHistory = async (
  userId: string,
  limit: number = 10
): Promise<ITrip[]> => {
  const trips = await Trip.find({ userId })
    .sort({ createdAt: -1 })
    .limit(limit)
    .populate("ambulanceId", "driverName vehicleNumber")
    .populate("destinationHospitalId", "name address");

  return trips;
};


/**
 * Get active trip for user
 */
const getActiveTrip = async (userId: string): Promise<ITrip | null> => {
  const trip = await Trip.findOne({
    userId,
    status: {
      $in: [
        "SEARCHING",
        "ACCEPTED",
        "ARRIVED_PICKUP",
        "EN_ROUTE_HOSPITAL",
        "ARRIVED_HOSPITAL",
      ],
    },
  })
    .populate("ambulanceId", "-password -refreshToken")
    .populate("destinationHospitalId", "-password -refreshToken")
    .lean();

  return trip;
};


export {
  createTripRequest,
  updateTripStatus,
  assignAmbulanceToTrip,
  cancelTrip,
  getTripDetails,
  getUserTripHistory,
  getActiveTrip
};



================================================================================
FILE: src/modules/trip/trip.dto/trip.dto.ts
================================================================================

// src/modules/trip/trip.dto/trip.dto.ts

import { z } from "zod";

// Location schema
const locationSchema = z.tuple([
  z.number().min(-180).max(180), // longitude
  z.number().min(-90).max(90),   // latitude
]);

// Create trip request schema
export const createTripSchema = z.object({
  pickupAddress: z.string().trim().optional(),
  pickupCoordinates: locationSchema,
  destinationHospitalId: z.string().optional(),
  bloodType: z
    .enum(["A+", "A-", "B+", "B-", "O+", "O-", "AB+", "AB-"])
    .optional(),
  requireBeds: z.boolean().default(false),
});

// Update trip status schema
export const updateTripStatusSchema = z.object({
  status: z.enum([
    "SEARCHING",
    "ACCEPTED",
    "ARRIVED_PICKUP",
    "EN_ROUTE_HOSPITAL",
    "ARRIVED_HOSPITAL",
    "COMPLETED",
    "CANCELLED",
  ]),
  location: locationSchema.optional(),
});

// Assign ambulance schema
export const assignAmbulanceSchema = z.object({
  ambulanceId: z.string().min(1, "Ambulance ID is required"),
});

// Cancel trip schema
export const cancelTripSchema = z.object({
  reason: z.string().trim().optional(),
});

// Query schema for trip history
export const tripHistoryQuerySchema = z.object({
  limit: z.coerce.number().min(1).max(50).default(10),
  status: z
    .enum([
      "SEARCHING",
      "ACCEPTED",
      "ARRIVED_PICKUP",
      "EN_ROUTE_HOSPITAL",
      "ARRIVED_HOSPITAL",
      "COMPLETED",
      "CANCELLED",
    ])
    .optional(),
});

// Type exports
export type CreateTripInput = z.infer<typeof createTripSchema>;
export type UpdateTripStatusInput = z.infer<typeof updateTripStatusSchema>;
export type AssignAmbulanceInput = z.infer<typeof assignAmbulanceSchema>;
export type CancelTripInput = z.infer<typeof cancelTripSchema>;
export type TripHistoryQuery = z.infer<typeof tripHistoryQuerySchema>;


================================================================================
FILE: src/modules/user/controller/user.controller.ts
================================================================================

import type { Request, Response } from "express";
import { ApiError } from "../../../shared/utils/ApiError.js";
import { ApiResponse } from "../../../shared/utils/ApiResponce.js";
import { asyncHandler } from "../../../shared/utils/AsyncHandler.js";
import { createUserSchema } from "../user.dto/user.dto.js";
import { User } from "../model/user.model.js";
import { NODE_ENV } from "../../../config/env.js";

/**
 * @description Register a new user
 * @route POST /api/v2/users/register
 * @access Public
 */
const registerUser = asyncHandler(async (req: Request, res: Response) => {
  // Validate request body
  const validationResult = createUserSchema.safeParse(req.body);

  if (!validationResult.success) {
    throw new ApiError(400, "Validation failed", validationResult.error.issues);
  }

  const { name, email, phone, password, bloodGroup, medicalHistory, location } =
    validationResult.data;

  // Check if user already exists
  const existingUser = await User.findOne({
    $or: [{ email }, { phone }],
  });

  if (existingUser) {
    throw new ApiError(
      409,
      existingUser.email === email
        ? "User with this email already exists"
        : "User with this phone number already exists"
    );
  }

  // Create user
  const user = await User.create({
    name,
    email,
    phone,
    password,
    bloodGroup,
    medicalHistory: medicalHistory || undefined,
    location,
  });

  // Fetch user without password and refreshToken
  const createdUser = await User.findById(user._id).select(
    "-password -refreshToken"
  );

  if (!createdUser) {
    throw new ApiError(500, "Failed to create user");
  }

  // Generate tokens
  const accessToken = createdUser.GetAccessToken();
  const refreshToken = createdUser.GetRefreshToken();

  // Update user with refresh token (avoid extra save with select exclusion)
  await User.findByIdAndUpdate(
    createdUser._id,
    { refreshToken },
    { new: false }
  );

  // Set cookies
  const cookieOptions = {
    httpOnly: true,
    secure: NODE_ENV === "production",
    sameSite: "strict" as const,
  };

  res
    .status(201)
    .cookie("accessToken", accessToken, {
      ...cookieOptions,
      maxAge: 15 * 60 * 1000,
    }) // 15 minutes
    .cookie("refreshToken", refreshToken, {
      ...cookieOptions,
      maxAge: 7 * 24 * 60 * 60 * 1000,
    }) // 7 days
    .json(
      new ApiResponse(
        201,
        {
          user: createdUser,
          accessToken,
          refreshToken,
        },
        "User registered successfully"
      )
    );
});

/**
 * @description Login user with email or phone
 * @route POST /api/v2/users/login
 * @access Public
 */
const loginUser = asyncHandler(async (req: Request, res: Response) => {
  // 1. Data is ALREADY validated and transformed by the middleware
  // req.body.email is already lowercased if it exists
  const { email, phone, password } = req.body;

  // 2. Determine the query dynamically
  // Since the schema guarantees at least one exists, we just check which one.
  const query = email ? { email } : { phone };
  console.log(query);
  console.log(password);

  // 3. Find User
  const user = await User.findOne(query).select(
    "+password +accessToken +refreshToken"
  );
  //   console.log(user)

  if (!user) {
    // Security Best Practice: Use generic error messages
    throw new ApiError(401, "Invalid credentials");
  }

  // 4. Verify password
  const isPasswordValid = await user.checkPassword(password);

  if (!isPasswordValid) {
    throw new ApiError(401, "Invalid credentials");
  }

  // 5. Generate tokens
  const accessToken = user.GetAccessToken();
  const refreshToken = user.GetRefreshToken();

  // 6. Save refresh token
  user.refreshToken = refreshToken;
  await user.save({ validateBeforeSave: false });

  // 7. Sanitize User (Remove sensitive fields)
  // .toObject() converts the Mongoose document to a plain JS object
  const loggedInUser = user.toObject();
  delete loggedInUser.password;
  delete loggedInUser.refreshToken;

  const cookieOptions = {
    httpOnly: true,
    secure: NODE_ENV === "production",
    sameSite: "strict" as const,
  };

  return res
    .status(200)
    .cookie("accessToken", accessToken, {
      ...cookieOptions,
      maxAge: 15 * 60 * 1000, // 15 mins
    })
    .cookie("refreshToken", refreshToken, {
      ...cookieOptions,
      maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
    })
    .json(
      new ApiResponse(
        200,
        {
          user: loggedInUser,
          accessToken,
          refreshToken,
        },
        "User logged in successfully"
      )
    );
});
/**
 * @description Logout user
 * @route POST /api/v2/users/logout
 * @access Private
 */
const logoutUser = asyncHandler(async (req: Request, res: Response) => {
  // Assuming you have authentication middleware that attaches user to req
  const userId = (req as any).user?._id;

  if (!userId) {
    throw new ApiError(401, "Unauthorized");
  }

  // Clear refresh token from database
  await User.findByIdAndUpdate(
    userId,
    {
      $set: { refreshToken: null },
    },
    { new: true }
  );

  // Clear cookies
  const cookieOptions = {
    httpOnly: true,
    secure: NODE_ENV === "production",
    sameSite: "strict" as const,
  };

  res
    .status(200)
    .clearCookie("accessToken", cookieOptions)
    .clearCookie("refreshToken", cookieOptions)
    .json(new ApiResponse(200, {}, "User logged out successfully"));
});

/**
 * @description Get current logged in user profile
 * @route GET /api/v2/user/me
 * @access Private
 */
const getUserProfile = asyncHandler(async (req: Request, res: Response) => {
  // req.ambulance is populated by verifyAmbulanceJWT middleware
  // It is already sanitized (password removed) by the middleware
  const user = req.user;
  if (!user) throw new ApiError(401, "Unauthorized - User not logged in");

  res
    .status(200)
    .json(
      new ApiResponse(200, user, "User profile fetched successfully")
    );
});

export { registerUser, loginUser, logoutUser, getUserProfile };



================================================================================
FILE: src/modules/user/model/user.model.ts
================================================================================

import mongoose, { Document, Schema, Types } from "mongoose";
import {
  hashPassword,
  verifyPassword,
  generateAccessToken,
  generateRefreshToken,
} from "../../../shared/utils/auth.util.js";

export interface IUser extends Document {
  _id: Types.ObjectId;
  name: string;
  phone: string;
  email: string;
  password?: string; 
  bloodGroup: "A+" | "A-" | "B+" | "B-" | "O+" | "O-" | "AB+" | "AB-";
  medicalHistory?: string | undefined;
  location: {
    type: "Point";
    coordinates: [number, number]; 
  };
  refreshToken?: string | null;

  // Methods defined on the schema
  checkPassword(password: string): Promise<boolean>;
  GetAccessToken(): string;
  GetRefreshToken(): string;
}

// 2. Define the Mongoose Schema
const UserSchema = new Schema<IUser>(
  {
    name: {
      type: String,
      required: true,
      trim: true,
      lowercase: true,
    },
    email: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      lowercase: true,
    },
    phone: {
      type: String,
      required: true,
      unique: true,
      trim: true,
    },
    password: {
      type: String,
      required: true,
      minlength: 6,
      select: false, 
    },
    bloodGroup: {
      type: String,
      enum: ["A+", "A-", "B+", "B-", "O+", "O-", "AB+", "AB-"],
      required: true,
    },
    medicalHistory: {
      type: String,
      default: null,
    },
    location: {
      type: {
        type: String,
        enum: ["Point"],
        required: true,
        default: "Point",
      },
      coordinates: {
        type: [Number], // [lng, lat]
        required: true,
      },
    },
    refreshToken: {
      type: String,
      default: null,
      select: false,
    },
  },
  { timestamps: true }
);

// 3. Add Geospatial Indexing (Critical for finding nearby ambulances)
UserSchema.index({ location: "2dsphere" });


// 4. Schema Hooks (Pre-save Middleware)
UserSchema.pre<IUser>("save", async function (this: IUser & Document) {
  // Only hash the password if it has been modified or is new
  if (!this.isModified("password")) return;

  // Use the imported utility function
  this.password = await hashPassword(this.password as string);
});

// 5. Schema Methods (Replicate existing functionality with strong typing)
UserSchema.methods.checkPassword = async function (this: IUser, enteredPassword: string): Promise<boolean> {
  if (!this.password) return false;
  return await verifyPassword(enteredPassword, this.password);
};

//added role
UserSchema.methods.GetAccessToken = function (this: IUser): string {
  return generateAccessToken({ id: this._id.toHexString(), role: "user" });
};

UserSchema.methods.GetRefreshToken = function (this: IUser): string {
  return generateRefreshToken({ id: this._id.toHexString(), role: "user" });
};

// 6. Export the Model
export const User = mongoose.model<IUser>("User", UserSchema);


================================================================================
FILE: src/modules/user/routes/user.routes.ts
================================================================================

import { Router } from "express";
import { z } from "zod";
import { validate } from "../../../shared/middlewares/validate.middleware.js";
import {
  createUserSchema,
  userEmailPhoneLoginSchema,
} from "../user.dto/user.dto.js";
import {
  registerUser,
  loginUser,
  logoutUser,
  getUserProfile,
} from "../controller/user.controller.js";
import { verifyUserJWT } from "../../../shared/middlewares/auth.middleware.js";
const router = Router();

// ============================================
// PUBLIC ROUTES
// ============================================

/**
 * @route   POST /api/v2/user/register
 * @desc    Register a new user
 * @access  Public
 */
router.post(
  "/register",
  validate(z.object({ body: createUserSchema })),
  registerUser
);

/**
 * @route   POST /api/v2/user/login
 * @desc    Login user with Email or Phone
 * @access  Public
 */
router.post(
  "/login",
  validate(z.object({ body: userEmailPhoneLoginSchema })),
  loginUser
);

// ============================================
// PROTECTED ROUTES
// ============================================

/**
 * @route   POST /api/v2/user/logout
 * @desc    Logout user and clear tokens
 * @access  Private
 */
router.post("/logout", verifyUserJWT, logoutUser);

/**
 * @route   GET /api/v2/ambulance/me
 * @desc    Get current ambulance profile
 * @access  Private
 */

router.get("/me", verifyUserJWT, getUserProfile);

export const userRoutes: ReturnType<typeof Router> = router;


================================================================================
FILE: src/modules/user/user.dto/user.dto.ts
================================================================================

import { z } from "zod";

// Zod schema for user location (GeoJSON Point)
const locationSchema = z.object({
  type: z.literal("Point"),
  coordinates: z.tuple([
    z.number().min(-180).max(180), // longitude
    z.number().min(-90).max(90), // latitude
  ]),
});

// Blood group enum schema
const bloodGroupSchema = z.enum([
  "A+",
  "A-",
  "B+",
  "B-",
  "O+",
  "O-",
  "AB+",
  "AB-",
]);

// Zod schema for user registration/creation
export const createUserSchema = z.object({
  name: z
    .string()
    .trim()
    .min(1, "Name is required")
    .transform((val) => val.toLowerCase()),
  email: z
    .string()
    .trim()
    .email("Invalid email format")
    .transform((val) => val.toLowerCase()),
  phone: z
    .string()
    .trim()
    .min(10, "Phone number must be at least 10 digits")
    .regex(/^[0-9+()-\s]+$/, "Invalid phone number format"),
  password: z.string().min(6, "Password must be at least 6 characters long"),
  bloodGroup: bloodGroupSchema,
  medicalHistory: z.string().optional(),
  location: locationSchema,
});

// Zod schema for user update (all fields optional)
export const updateUserSchema = z.object({
  name: z
    .string()
    .trim()
    .min(1)
    .transform((val) => val.toLowerCase())
    .optional(),
  email: z
    .string()
    .trim()
    .email("Invalid email format")
    .transform((val) => val.toLowerCase())
    .optional(),
  phone: z
    .string()
    .trim()
    .min(10, "Phone number must be at least 10 digits")
    .regex(/^[0-9+()-\s]+$/, "Invalid phone number format")
    .optional(),
  password: z
    .string()
    .min(6, "Password must be at least 6 characters long")
    .optional(),
  bloodGroup: bloodGroupSchema.optional(),
  medicalHistory: z.string().optional().nullable(),
  location: locationSchema.optional(),
});

// Zod schema for user login (email or phone)
export const userLoginSchema = z.object({
  identifier: z.string().trim().min(1, "Email or phone number is required"),
  password: z.string().min(1, "Password is required"),
});

// Zod schema for email or phone login
export const userEmailPhoneLoginSchema = z
  .object({
    email: z
      .string()
      .trim()
      .email("Invalid email format")
      .transform((val) => val.toLowerCase())
      .optional(),
    phone: z
      .string()
      .trim()
      .min(10, "Phone number must be at least 10 digits")
      .optional(),
    password: z.string().min(1, "Password is required"),
  })
  .refine((data) => data.email || data.phone, {
    message: "Either email or phone number is required",
    path: ["email"], // Attaches error to email field if both are missing
  });

// Zod schema for updating user location
export const updateUserLocationSchema = z.object({
  location: locationSchema,
});

// Zod schema for updating medical history
export const updateMedicalHistorySchema = z.object({
  medicalHistory: z.string(),
});

// Zod schema for password change
export const changePasswordSchema = z
  .object({
    currentPassword: z.string().min(1, "Current password is required"),
    newPassword: z
      .string()
      .min(6, "New password must be at least 6 characters long"),
    confirmPassword: z.string().min(1, "Password confirmation is required"),
  })
  .refine((data) => data.newPassword === data.confirmPassword, {
    message: "Passwords do not match",
    path: ["confirmPassword"],
  });

// Zod schema for searching users by blood group
export const searchByBloodGroupSchema = z.object({
  bloodGroup: bloodGroupSchema,
  longitude: z.coerce.number().min(-180).max(180).optional(),
  latitude: z.coerce.number().min(-90).max(90).optional(),
  maxDistance: z.coerce.number().positive().default(10000).optional(), // in meters
});

// Type exports for TypeScript
export type CreateUserInput = z.infer<typeof createUserSchema>;
export type UpdateUserInput = z.infer<typeof updateUserSchema>;
export type UserLoginInput = z.infer<typeof userLoginSchema>;
export type UserEmailLoginInput = z.infer<typeof userEmailPhoneLoginSchema>;
export type UserPhoneLoginInput = z.infer<typeof userEmailPhoneLoginSchema>;
export type UpdateUserLocationInput = z.infer<typeof updateUserLocationSchema>;
export type UpdateMedicalHistoryInput = z.infer<
  typeof updateMedicalHistorySchema
>;
export type ChangePasswordInput = z.infer<typeof changePasswordSchema>;
export type SearchByBloodGroupInput = z.infer<typeof searchByBloodGroupSchema>;



================================================================================
FILE: src/shared/infra/sockets/events/location.events.ts
================================================================================

import type { AuthenticatedSocket } from "../socket.middleware/socket.middleware.js";
import redis from "../../../../config/redis.js";
import { Trip } from "../../../../modules/trip/model/trip.model.js";
// import { Ambulance } from "../../../../modules/ambulance/model/ambulance.model.js";

interface LocationUpdatePayload {
  tripId: string;
  location: {
    latitude: number;
    longitude: number;
    accuracy?: number;
    heading?: number;
    speed?: number;
  };
}

interface LocationUpdatePayload {
  tripId: string;
  location: {
    latitude: number;
    longitude: number;
    accuracy?: number;
    heading?: number;
    speed?: number;
  };
}

/**
 * Register all location-related socket events
 */
const registerLocationEvents = (socket: AuthenticatedSocket) => {
  const { userId, userRole } = socket;

  // Safety check - this should never happen after auth middleware
  if (!userId || !userRole) {
    console.error("Socket missing userId or userRole");
    return;
  }

  /**
   * Update real-time location during a trip
   */
  socket.on(
    "location_update",
    async (payload: LocationUpdatePayload, callback) => {
      try {
        const { tripId, location } = payload;

        // Validation
        if (!tripId || !location?.latitude || !location?.longitude) {
          return callback?.({ success: false, message: "Invalid payload" });
        }

        // Verify trip exists and user is part of it
        const trip = await Trip.findById(tripId).lean();

        if (!trip) {
          return callback?.({ success: false, message: "Trip not found" });
        }

        // Only user and ambulance can send location updates
        const isAuthorized =
          (userRole === "user" && trip.userId.toString() === userId) ||
          (userRole === "ambulance" && trip.ambulanceId?.toString() === userId);

        if (!isAuthorized) {
          return callback?.({
            success: false,
            message: "Unauthorized: Only trip participants can send location",
          });
        }

        // Store in Redis with TTL (for real-time tracking)
        const locationKey = `location:${userRole}:${tripId}`;
        const locationData = {
          ...location,
          userId,
          userRole,
          timestamp: new Date().toISOString(),
        };

        await redis.set(locationKey, JSON.stringify(locationData), {
          EX: 300, // Expire after 5 minutes
        });

        // If ambulance, also update their location in ambulance_locations geo index
        if (userRole === "ambulance") {
          await redis.geoAdd("ambulance_locations", {
            member: userId,
            longitude: location.longitude,
            latitude: location.latitude,
          });
        }

        // Broadcast to trip room (excluding sender)
        socket.to(`trip:${tripId}`).emit("location_updated", {
          userId,
          userRole,
          location,
          timestamp: new Date().toISOString(),
        });

        // Optionally persist to MongoDB (throttled - e.g., every 30 seconds)
        // You can implement this with a rate limiter or time-based check

        callback?.({ success: true, message: "Location updated" });
      } catch (error) {
        console.error("location_update error:", error);
        callback?.({ success: false, message: "Server error" });
      }
    }
  );

  /**
   * Get current location of a participant
   */
  socket.on(
    "get_location",
    async (
      payload: { tripId: string; targetRole: "user" | "ambulance" },
      callback
    ) => {
      try {
        const { tripId, targetRole } = payload;

        if (!tripId || !targetRole) {
          return callback?.({ success: false, message: "Invalid payload" });
        }

        // Verify requester is part of the trip
        const trip = await Trip.findById(tripId).lean();

        if (!trip) {
          return callback?.({ success: false, message: "Trip not found" });
        }

        const isAuthorized =
          userRole === "admin" ||
          trip.userId.toString() === userId ||
          trip.ambulanceId?.toString() === userId;

        if (!isAuthorized) {
          return callback?.({ success: false, message: "Unauthorized" });
        }

        // Fetch location from Redis
        const locationKey = `location:${targetRole}:${tripId}`;
        console.log(`üîç Looking for location key: ${locationKey}`);

        const locationData = await redis.get(locationKey);
        console.log(`üìç Location data found:`, locationData);

        if (!locationData) {
          // Try to get the most recent location from any key for this trip
          const allKeys = await redis.keys(`location:*:${tripId}`);
          console.log(`üîë Available location keys:`, allKeys);

          if (allKeys.length > 0) {
            const firstkey = allKeys[0];
            const fallbackData = await redis.get(firstkey!);
            if (fallbackData) {
              return callback?.({
                success: true,
                location: JSON.parse(fallbackData),
                note: "Using fallback location",
              });
            }
          }

          return callback?.({
            success: false,
            message: `Location not available for ${targetRole}. Make sure they've sent location first.`,
          });
        }

        callback?.({
          success: true,
          location: JSON.parse(locationData),
        });
      } catch (error) {
        console.error("get_location error:", error);
        callback?.({ success: false, message: "Server error" });
      }
    }
  );

  /**
   * Emergency SOS alert
   */
  socket.on(
    "emergency_sos",
    async (payload: { tripId: string; message?: string }, callback) => {
      try {
        const { tripId, message } = payload;

        if (!tripId) {
          return callback?.({ success: false, message: "Trip ID is required" });
        }

        // Verify trip
        const trip = await Trip.findById(tripId).lean();

        if (!trip) {
          return callback?.({ success: false, message: "Trip not found" });
        }

        // Broadcast SOS to trip room + admins
        const sosData = {
          tripId,
          userId,
          userRole,
          message: message || "Emergency SOS triggered!",
          timestamp: new Date().toISOString(),
        };

        socket.to(`trip:${tripId}`).emit("emergency_sos", sosData);
        socket.to("admin-room").emit("emergency_sos", sosData);

        console.log(
          `üö® SOS triggered by ${userRole} ${userId} in trip ${tripId}`
        );

        callback?.({ success: true, message: "SOS sent" });
      } catch (error) {
        console.error("emergency_sos error:", error);
        callback?.({ success: false, message: "Server error" });
      }
    }
  );
};

export { registerLocationEvents };



================================================================================
FILE: src/shared/infra/sockets/events/trip.events.ts
================================================================================

import type { AuthenticatedSocket } from "../socket.middleware/socket.middleware.js";
import redis from "../../../../config/redis.js";
import { Trip } from "../../../../modules/trip/model/trip.model.js";
import type mongoose from "mongoose";

interface JoinTripPayload {
  tripId: string | mongoose.Types.ObjectId;
}

interface LeaveTripPayload {
  tripId: string | mongoose.Types.ObjectId;
}

interface PopulatedUser {
  _id: mongoose.Types.ObjectId;
  name: string;
  phone: string;
}

interface PopulatedAmbulance {
  _id: mongoose.Types.ObjectId;
  driverName: string;
  vehicleNumber: string;
}

/**
 * Register all trip-related socket events
 */

const registerTripEvents = (socket: AuthenticatedSocket) => {
  const { userId, userRole } = socket;

  /**
   * Join a trip room
   */
  socket.on("join_trip", async (payload: JoinTripPayload, callback) => {
    try {
      const { tripId } = payload;

      if (!tripId) {
        return callback?.({ success: false, message: "Trip ID is required" });
      }

      // Verify trip exists
      const trip = await Trip.findById(tripId)
        .populate<{ userId: PopulatedUser }>("userId", "name phone")
        .populate<{ ambulanceId: PopulatedAmbulance }>("ambulanceId", "driverName vehicleNumber")
        .lean();

      if (!trip) {
        return callback?.({ success: false, message: "Trip not found" });
      }

      // Authorization check
      const isAuthorized = userRole === "admin" || trip.userId._id.toString() === userId || trip.ambulanceId?._id?.toString() === userId;

      if (!isAuthorized) {
        return callback?.({
          success: false,
          message: "Unauthorized: You are not part of this trip",
        });
      }

      // Join room
      const roomName = `trip:${tripId}`;
      socket.join(roomName);

      // Track room participants in Redis
      await redis.sAdd(`trip_participants:${tripId}`, socket.id);

      console.log(`üìç ${userRole} ${userId} joined ${roomName}`);

      // Notify other participants
      socket.to(roomName).emit("participant_joined", {
        userId,
        userRole,
        socketId: socket.id,
        timestamp: new Date().toISOString(),
      });

      // Send trip data to the joiner
      callback?.({
        success: true,
        message: "Successfully joined trip",
        trip: trip,
      });
    } catch (error) {
      console.error("join_trip error:", error);
      callback?.({ success: false, message: "Server error" });
    }
  });

  /**
   * Leave a trip room
   */
  socket.on("leave_trip", async (payload: LeaveTripPayload, callback) => {
    try {
      const { tripId } = payload;

      if (!tripId) {
        return callback?.({ success: false, message: "Trip ID is required" });
      }

      const roomName = `trip:${tripId}`;
      socket.leave(roomName);

      // Remove from Redis tracking
      await redis.sRem(`trip_participants:${tripId}`, socket.id);

      console.log(`üìç ${userRole} ${userId} left ${roomName}`);

      // Notify other participants
      socket.to(roomName).emit("participant_left", {
        userId,
        userRole,
        socketId: socket.id,
        timestamp: new Date().toISOString(),
      });

      callback?.({ success: true, message: "Successfully left trip" });
    } catch (error) {
      console.error("leave_trip error:", error);
      callback?.({ success: false, message: "Server error" });
    }
  });

  /**
   * Get active participants in a trip
   */
  socket.on(
    "get_trip_participants",
    async (payload: { tripId: string }, callback) => {
      try {
        const { tripId } = payload;

        if (!tripId) {
          return callback?.({ success: false, message: "Trip ID is required" });
        }

        // Get all socket IDs in this trip room
        const socketIds = await redis.sMembers(`trip_participants:${tripId}`);

        // Get their user info
        const participants = await Promise.all(
          socketIds.map(async (socketId) => {
            const data = await redis.hGet("socket:mapping", socketId);
            return data ? JSON.parse(data) : null;
          })
        );

        callback?.({
          success: true,
          participants: participants.filter(Boolean),
          count: participants.length,
        });
      } catch (error) {
        console.error("get_trip_participants error:", error);
        callback?.({ success: false, message: "Server error" });
      }
    }
  );
};


export {
    registerTripEvents
}


================================================================================
FILE: src/shared/infra/sockets/handlers/connection.handler.ts
================================================================================

import type { AuthenticatedSocket } from "../socket.middleware/socket.middleware.js";
import { registerTripEvents } from "../events/trip.events.js";
import { registerLocationEvents } from "../events/location.events.js";
import redis from "../../../../config/redis.js";

/**
 * Main connection handler - sets up all event listeners
 */
const connectionHandler = async (socket: AuthenticatedSocket) => {
  const { userId, userRole } = socket;

  console.log(`üîå Client connected: ${userRole} ${userId} (socket: ${socket.id})`);

  // Store socket mapping in Redis for quick lookups
  try {
    await redis.hSet("socket:mapping", socket.id, JSON.stringify({
      userId,
      userRole,
      connectedAt: new Date().toISOString()
    }));

    // Also store reverse mapping (userId -> socketId)
    await redis.set(`socket:${userRole}:${userId}`, socket.id, {
      EX: 3600 // Expire in 1 hour
    });
  } catch (error) {
    console.error("Redis socket mapping error:", error);
  }

  // Auto-join admin room if admin
  if (userRole === "admin") {
    socket.join("admin-room");
    console.log(`üëÆ Admin ${userId} joined admin-room`);
  }

  // Register event handlers
  registerTripEvents(socket);
  registerLocationEvents(socket);

  // Simple echo test for debugging
  socket.on("echo_test", (data: any, callback) => {
    console.log("üì® Echo test received:", data);
    callback?.({
      success: true,
      echo: data,
      serverTime: new Date().toISOString(),
      socketId: socket.id
    });
  });

  // Handle disconnection
  socket.on("disconnect", async (reason) => {
    console.log(`üîå Client disconnected: ${userRole} ${userId} (reason: ${reason})`);

    // Clean up Redis mappings
    try {
      await redis.hDel("socket:mapping", socket.id);
      await redis.del(`socket:${userRole}:${userId}`);
    } catch (error) {
      console.error("Redis cleanup error:", error);
    }

    // Notify trip participants if user was in a trip
    const rooms = Array.from(socket.rooms);
    const tripRooms = rooms.filter(room => room.startsWith("trip:"));
    
    tripRooms.forEach(room => {
      socket.to(room).emit("participant_disconnected", {
        userId,
        userRole,
        timestamp: new Date().toISOString()
      });
    });
  });

  // Send welcome message
  socket.emit("connected", {
    message: "Successfully connected to MedSwift",
    socketId: socket.id,
    userId,
    userRole,
    timestamp: new Date().toISOString()
  });
};

export {
    connectionHandler
}


================================================================================
FILE: src/shared/infra/sockets/socket.config.ts
================================================================================

// src/shared/infra/socket/socket.config.ts

import { Server as SocketServer } from "socket.io";
import type { Server as HTTPServer } from "http";
import { socketAuthMiddleware } from "./socket.middleware/socket.middleware.js";
import { connectionHandler } from "./handlers/connection.handler.js";

let io: SocketServer | null = null;

/**
 * Initialize Socket.IO server
 */
export const initializeSocket = (httpServer: HTTPServer): SocketServer => {
  io = new SocketServer(httpServer, {
    cors: {
      origin: "http://localhost:5000", // Match your Express CORS
      credentials: true,
      methods: ["GET", "POST"]
    },
    // Connection settings
    pingTimeout: 60000, // 60 seconds - wait time before considering connection lost
    pingInterval: 25000, // 25 seconds - ping frequency
    upgradeTimeout: 30000, // 30 seconds - WebSocket upgrade timeout
    maxHttpBufferSize: 1e8, // 100 MB max message size
    transports: ["websocket", "polling"], // Prefer WebSocket
    allowEIO3: true, // Allow Engine.IO v3 clients
  });

  // Apply authentication middleware
  io.use(socketAuthMiddleware);

  // Handle connections
  io.on("connection", connectionHandler);

  console.log("‚úÖ Socket.IO initialized");
  return io;
};

/**
 * Get Socket.IO instance (for emitting from controllers)
 */
export const getIO = (): SocketServer => {
  if (!io) {
    throw new Error("Socket.IO not initialized. Call initializeSocket() first.");
  }
  return io;
};

/**
 * Emit event to a specific trip room
 */
export const emitToTrip = (tripId: string, event: string, data: any): void => {
  const io = getIO();
  io.to(`trip:${tripId}`).emit(event, data);
};

/**
 * Emit event to all admins
 */
export const emitToAdmins = (event: string, data: any): void => {
  const io = getIO();
  io.to("admin-room").emit(event, data);
};


================================================================================
FILE: src/shared/infra/sockets/socket.middleware/socket.middleware.ts
================================================================================

import type { Socket } from "socket.io";
import jwt from "jsonwebtoken";
import { ACCESS_TOKEN_SECRET } from "../../../../config/env.js";
import { Ambulance } from "../../../../modules/ambulance/model/ambulance.model.js";
import { User } from "../../../../modules/user/model/user.model.js";
import { Admin } from "../../../../modules/admin/models/admin.model.js";

interface JwtPayload {
  id: string;
  role: "user" | "ambulance" | "admin";
  iat?: number;
  exp?: number;
}

// Extend Socket type to include authenticated data
export interface AuthenticatedSocket extends Socket {
  userId?: string;
  userRole?: "user" | "ambulance" | "admin";
  userData?: any; // Full user/ambulance/admin document
}

/**
 * Socket.IO authentication middleware
 * Verifies JWT token from handshake auth or query params
 */
export const socketAuthMiddleware = async (
  socket: AuthenticatedSocket,
  next: (err?: Error) => void
) => {
  try {
    // Extract token from handshake (supports both auth and query)
    const token =
      socket.handshake.auth?.token || 
      socket.handshake.query?.token;

    if (!token || typeof token !== "string") {
      return next(new Error("Authentication error: No token provided"));
    }

    // Verify JWT
    let decoded: JwtPayload;
    try {
      decoded = jwt.verify(token, ACCESS_TOKEN_SECRET) as JwtPayload;
    } catch (err) {
      return next(new Error("Authentication error: Invalid token"));
    }

    // Fetch user data based on role
    let userData: any = null;

    switch (decoded.role) {
      case "user":
        userData = await User.findById(decoded.id).select("-password -refreshToken");
        break;
      case "ambulance":
        userData = await Ambulance.findById(decoded.id).select("-password -refreshToken");
        break;
      case "admin":
        userData = await Admin.findById(decoded.id).select("-password -refreshToken");
        break;
      default:
        return next(new Error("Authentication error: Invalid role"));
    }

    if (!userData) {
      return next(new Error("Authentication error: User not found"));
    }

    // Attach to socket
    socket.userId = decoded.id;
    socket.userRole = decoded.role;
    socket.userData = userData;

    console.log(`‚úÖ Socket authenticated: ${decoded.role} ${decoded.id}`);
    next();
  } catch (error) {
    console.error("Socket auth error:", error);
    next(new Error("Authentication error"));
  }
};


================================================================================
FILE: src/shared/middlewares/auth.middleware.ts
================================================================================

import { User } from "../../modules/user/model/user.model.js";
import { Ambulance } from "../../modules/ambulance/model/ambulance.model.js";
import { asyncHandler } from "../utils/AsyncHandler.js";
import { ApiError } from "../utils/ApiError.js";
import type { Request, Response, NextFunction } from "express";
import jwt from "jsonwebtoken";
import { ACCESS_TOKEN_SECRET } from "../../config/env.js";
import { Admin } from "../../modules/admin/models/admin.model.js";
import { Hospital } from "../../modules/hospital/model/hospital.model.js";

// Extend Express Request type
declare global {
  namespace Express {
    interface Request {
      user?: any;
      ambulance?: any;
      admin?:any;
      hospital?:any;
    }
  }
}

// JWT Payload interface
interface JwtPayload {
  id: string;
  role?: "ambulance" | "admin" | "user" | "hospital"; 
  iat?: number;
  exp?: number;
}

/**
 * @description Verify JWT and attach user to request
 * @middleware
 */
const verifyUserJWT = asyncHandler(
  async (req: Request, res: Response, next: NextFunction) => {
    // Extract token from cookies or Authorization header
    const token =
      req.cookies?.accessToken ||
      req.header("Authorization")?.replace("Bearer ", "");

    if (!token) {
      throw new ApiError(401, "Unauthorized - No token provided");
    }

    // Verify token
    let decodedToken: JwtPayload;
    try {
      decodedToken = jwt.verify(token, ACCESS_TOKEN_SECRET) as JwtPayload;
    } catch (error) {
      throw new ApiError(401, "Unauthorized - Invalid or expired token");
    }

    // Check if token is for ambulance (not allowed)
    if (decodedToken.role === "ambulance") {
      throw new ApiError(
        403,
        "Forbidden - Ambulance token not allowed for user routes"
      );
    }

    // Find user (IMPORTANT: await the promise!)
    const user = await User.findById(decodedToken.id).select(
      "-password -refreshToken"
    );

    if (!user) {
      throw new ApiError(401, "Unauthorized - User not found");
    }

    // Attach user to request
    req.user = user;
    next();
  }
);

/**
 * @description Verify JWT and attach ambulance to request
 * @middleware
 */
const verifyAmbulanceJWT = asyncHandler(
  async (req: Request, res: Response, next: NextFunction) => {
    // Extract token from cookies or Authorization header
    const token =
      req.cookies?.accessToken ||
      req.header("Authorization")?.replace("Bearer ", "");

    if (!token) {
      throw new ApiError(401, "Unauthorized - No token provided");
    }

    // Verify token
    let decodedToken: JwtPayload;
    try {
      decodedToken = jwt.verify(token, ACCESS_TOKEN_SECRET) as JwtPayload;
    } catch (error) {
      throw new ApiError(401, "Unauthorized - Invalid or expired token");
    }

    // Verify role is ambulance
    if (decodedToken.role !== "ambulance") {
      throw new ApiError(403, "Forbidden - Invalid user type");
    }

    // Find ambulance (IMPORTANT: await the promise!)
    const ambulance = await Ambulance.findById(decodedToken.id).select(
      "-password -refreshToken"
    );

    if (!ambulance) {
      throw new ApiError(401, "Unauthorized - Ambulance not found");
    }

    // Attach ambulance to request
    req.ambulance = ambulance;
    next();
  }
);

/**
 * @description Verify JWT and attach hospital to request
 * @middleware
 */
const verifyHospitalJWT = asyncHandler(
  async (req: Request, res: Response, next: NextFunction) => {
    const token =
      req.cookies?.accessToken ||
      req.header("Authorization")?.replace("Bearer ", "");

    if (!token) {
      throw new ApiError(401, "Unauthorized - No token provided");
    }

    let decodedToken: JwtPayload;
    try {
      decodedToken = jwt.verify(token, ACCESS_TOKEN_SECRET) as JwtPayload;
    } catch (error) {
      throw new ApiError(401, "Unauthorized - Invalid or expired token");
    }

    if (decodedToken.role !== "hospital") {
      throw new ApiError(403, "Forbidden - Hospital token required");
    }

    const hospital = await Hospital.findById(decodedToken.id).select(
      "-password -refreshToken"
    );

    if (!hospital) {
      throw new ApiError(401, "Unauthorized - Hospital not found");
    }

    req.hospital = hospital;
    next();
  }
);

/**
 * @description Generic JWT verification (detects entity based on token role)
 * @middleware
 */
const verifyJWT = asyncHandler(
  async (req: Request, res: Response, next: NextFunction) => {
    const token =
      req.cookies?.accessToken ||
      req.header("Authorization")?.replace("Bearer ", "");

    if (!token) {
      throw new ApiError(401, "Unauthorized - No token provided");
    }

    let decodedToken: JwtPayload;
    try {
      decodedToken = jwt.verify(token, ACCESS_TOKEN_SECRET) as JwtPayload;
    } catch (error) {
      throw new ApiError(401, "Unauthorized - Invalid or expired token");
    }

    // Route to appropriate entity based on role
    switch (decodedToken.role) {
      case "ambulance": {
        const ambulance = await Ambulance.findById(decodedToken.id).select(
          "-password -refreshToken"
        );
        if (!ambulance) {
          throw new ApiError(401, "Unauthorized - Ambulance not found");
        }
        req.ambulance = ambulance;
        break;
      }
      case "hospital": {
        const hospital = await Hospital.findById(decodedToken.id).select(
          "-password -refreshToken"
        );
        if (!hospital) {
          throw new ApiError(401, "Unauthorized - Hospital not found");
        }
        req.hospital = hospital;
        break;
      }
      case "admin": {
        const admin = await Admin.findById(decodedToken.id).select(
          "-password -refreshToken"
        );
        if (!admin) {
          throw new ApiError(401, "Unauthorized - Admin not found");
        }
        req.admin = admin;
        break;
      }
      default: {
        const user = await User.findById(decodedToken.id).select(
          "-password -refreshToken"
        );
        if (!user) {
          throw new ApiError(401, "Unauthorized - User not found");
        }
        req.user = user;
      }
    }

    next();
  }
);


/**
 * @description Verify JWT and attach ADMIN to request
 * @middleware
 */
const verifyAdminJWT = asyncHandler(
  async (req: Request, res: Response, next: NextFunction) => {
    const token = req.cookies?.accessToken || req.header("Authorization")?.replace("Bearer ", "");

    if (!token) {
      throw new ApiError(401, "Unauthorized - No token provided");
    }

    try {
      const decodedToken = jwt.verify(token, ACCESS_TOKEN_SECRET) as JwtPayload;

      // STRICT CHECK: Role must be admin
      if (decodedToken.role !== "admin") {
        throw new ApiError(403, "Forbidden - Requires Admin Privileges");
      }

      const admin = await Admin.findById(decodedToken.id).select("-password -refreshToken");

      if (!admin) {
        throw new ApiError(401, "Unauthorized - Admin not found");
      }

      req.admin = admin;
      next();
    } catch (error) {
      throw new ApiError(401, "Unauthorized - Invalid or expired token");
    }
  }
);

export { verifyJWT, verifyUserJWT, verifyAmbulanceJWT, verifyAdminJWT, verifyHospitalJWT};



================================================================================
FILE: src/shared/middlewares/validate.middleware.ts
================================================================================

import type { Request, Response, NextFunction } from "express";
import { ZodError, ZodType } from "zod";
import { ApiError } from "../utils/ApiError.js";

export const validate =
  (schema: ZodType) =>
  async (req: Request, res: Response, next: NextFunction) => {
    // console.log(req)
    try {
      await schema.parseAsync({
        body: req.body,
        query: req.query,
        params: req.params,
      });
      return next();
    } catch (error) {
      if (error instanceof ZodError) {
        const errors = error.issues.map((err) => ({
          field: err.path.join("."),
          message: err.message,
        }));
        return next(new ApiError(400, "Validation Failed", errors));
      }
      return next(error);
    }
  };


================================================================================
FILE: src/shared/utils/ApiError.ts
================================================================================

class ApiError extends Error {
  statusCode: number;
  data: null;
  success: boolean;
  errors: unknown[];

  constructor(
    statusCode: number,
    message: string = "something went wrong",
    errors: unknown[] = [],
    stack: string = ""
  ) {
    super(message);

    this.statusCode = statusCode;
    this.data = null;
    this.success = false;
    this.errors = errors;

    if (stack) {
      this.stack = stack;
    } else {
      (Error as any).captureStackTrace(this, this.constructor);
    }
  }
}

export { ApiError };



================================================================================
FILE: src/shared/utils/ApiResponce.ts
================================================================================

class ApiResponse<T = unknown> {
  statusCode: number;
  message: string;
  data: T;
  status: boolean;

  constructor(
    statusCode: number,
    data: T,
    message: string = "Success"
  ) {
    this.statusCode = statusCode;
    this.message = message;
    this.data = data;
    this.status = statusCode < 400;
  }
}

export { ApiResponse };



================================================================================
FILE: src/shared/utils/AsyncHandler.ts
================================================================================

import type { Request, Response, NextFunction } from "express";

const asyncHandler =
  (requestHandler: (req: Request, res: Response, next: NextFunction) => Promise<any>) =>
  (req: Request, res: Response, next: NextFunction): void => {
    Promise.resolve(requestHandler(req, res, next)).catch(next);
  };

export { asyncHandler };



================================================================================
FILE: src/shared/utils/auth.util.ts
================================================================================

import jwt from "jsonwebtoken";
import type { JwtPayload } from "jsonwebtoken";
import bcrypt from "bcrypt";
import { ApiError } from "./ApiError.js";
import { ACCESS_TOKEN_SECRET, REFRESH_TOKEN_SECRET  } from "../../config/env.js" ;

if (!ACCESS_TOKEN_SECRET || !REFRESH_TOKEN_SECRET) {
  throw new ApiError(500, "JWT secrets are not defined in environment variables");
}

const SALT_ROUNDS = 10;

// ---------------- PASSWORD ----------------

export const hashPassword = async (password: string): Promise<string> => {
  return bcrypt.hash(password, SALT_ROUNDS);
};

export const verifyPassword = async (
  password: string,
  hashedPassword: string
): Promise<boolean> => {
  return bcrypt.compare(password, hashedPassword);
};

// ---------------- TOKENS ----------------

type TokenPayload = JwtPayload | object;

export const generateAccessToken = (payload: TokenPayload): string => {
  return jwt.sign(payload, ACCESS_TOKEN_SECRET, {
    expiresIn: "15m",
  });
};

export const generateRefreshToken = (payload: TokenPayload): string => {
  return jwt.sign(payload, REFRESH_TOKEN_SECRET, {
    expiresIn: "7d",
  });
};



================================================================================
FILE: src/tests/index.html
================================================================================

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MedSwift Socket.IO Test</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>
<body class="bg-gray-900 text-white min-h-screen p-6">
    <div class="max-w-7xl mx-auto">
        <!-- Header -->
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold text-blue-400 mb-2">üöë MedSwift Socket.IO Tester</h1>
            <p class="text-gray-400">Test your real-time ambulance tracking system</p>
        </div>

        <!-- Connection Section -->
        <div class="bg-gray-800 rounded-lg p-6 mb-6">
            <h2 class="text-2xl font-semibold mb-4 text-green-400">1Ô∏è‚É£ Connection</h2>
            
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium mb-2">Server URL</label>
                    <input type="text" id="serverUrl" value="http://localhost:5000" 
                           class="w-full bg-gray-700 border border-gray-600 rounded px-4 py-2 focus:outline-none focus:border-blue-500">
                    <p class="text-xs text-gray-500 mt-1">‚ö†Ô∏è If using port 8000, change to http://localhost:8000</p>
                </div>

                <div>
                    <label class="block text-sm font-medium mb-2">JWT Token</label>
                    <textarea id="jwtToken" rows="3" placeholder="Paste your JWT token here (from login API response)"
                              class="w-full bg-gray-700 border border-gray-600 rounded px-4 py-2 focus:outline-none focus:border-blue-500 font-mono text-xs"></textarea>
                    <p class="text-xs text-gray-500 mt-1">Get this from POST /api/v2/user/login or /api/v2/ambulance/login</p>
                </div>

                <div class="flex gap-4">
                    <button onclick="connectSocket()" class="bg-green-600 hover:bg-green-700 px-6 py-2 rounded font-semibold transition">
                        üîå Connect
                    </button>
                    <button onclick="disconnectSocket()" class="bg-red-600 hover:bg-red-700 px-6 py-2 rounded font-semibold transition">
                        ‚ùå Disconnect
                    </button>
                </div>

                <div id="connectionStatus" class="p-4 rounded bg-gray-700 border-l-4 border-gray-500">
                    <span class="font-semibold">Status:</span> <span id="statusText">Not Connected</span>
                </div>
            </div>
        </div>

        <!-- Grid Layout for Actions and Logs -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <!-- Trip Actions -->
            <div class="bg-gray-800 rounded-lg p-6">
                <h2 class="text-2xl font-semibold mb-4 text-purple-400">2Ô∏è‚É£ Trip Actions</h2>
                
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium mb-2">Trip ID</label>
                        <input type="text" id="tripId" placeholder="e.g., 676a3f8e5c1e4b2a1d9f3c4e"
                               class="w-full bg-gray-700 border border-gray-600 rounded px-4 py-2 focus:outline-none focus:border-blue-500 font-mono text-sm">
                    </div>

                    <div class="grid grid-cols-2 gap-2">
                        <button onclick="joinTrip()" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded transition">
                            üìç Join Trip
                        </button>
                        <button onclick="leaveTrip()" class="bg-yellow-600 hover:bg-yellow-700 px-4 py-2 rounded transition">
                            üö™ Leave Trip
                        </button>
                    </div>

                    <button onclick="getTripParticipants()" class="w-full bg-purple-600 hover:bg-purple-700 px-4 py-2 rounded transition">
                        üë• Get Participants
                    </button>
                </div>
            </div>

            <!-- Location Actions -->
            <div class="bg-gray-800 rounded-lg p-6">
                <h2 class="text-2xl font-semibold mb-4 text-orange-400">3Ô∏è‚É£ Location Tracking</h2>
                
                <div class="space-y-4">
                    <div class="grid grid-cols-2 gap-2">
                        <div>
                            <label class="block text-sm font-medium mb-2">Latitude</label>
                            <input type="number" id="latitude" value="13.0827" step="0.0001"
                                   class="w-full bg-gray-700 border border-gray-600 rounded px-4 py-2 focus:outline-none focus:border-blue-500">
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-2">Longitude</label>
                            <input type="number" id="longitude" value="80.2707" step="0.0001"
                                   class="w-full bg-gray-700 border border-gray-600 rounded px-4 py-2 focus:outline-none focus:border-blue-500">
                        </div>
                    </div>

                    <button onclick="sendLocation()" class="w-full bg-green-600 hover:bg-green-700 px-4 py-2 rounded transition">
                        üì° Send Location
                    </button>

                    <div class="grid grid-cols-2 gap-2">
                        <button onclick="startAutoLocation()" class="bg-teal-600 hover:bg-teal-700 px-4 py-2 rounded transition text-sm">
                            ‚ñ∂Ô∏è Auto Send (3s)
                        </button>
                        <button onclick="stopAutoLocation()" class="bg-red-600 hover:bg-red-700 px-4 py-2 rounded transition text-sm">
                            ‚èπÔ∏è Stop Auto
                        </button>
                    </div>

                    <button onclick="getLocation('user')" class="w-full bg-indigo-600 hover:bg-indigo-700 px-4 py-2 rounded transition text-sm">
                        üìç Get User Location
                    </button>
                    <button onclick="getLocation('ambulance')" class="w-full bg-indigo-600 hover:bg-indigo-700 px-4 py-2 rounded transition text-sm">
                        üöë Get Ambulance Location
                    </button>
                </div>
            </div>
        </div>

        <!-- Emergency Section -->
        <div class="bg-gray-800 rounded-lg p-6 mt-6">
            <h2 class="text-2xl font-semibold mb-4 text-red-400">4Ô∏è‚É£ Emergency</h2>
            <div class="flex gap-4">
                <input type="text" id="sosMessage" placeholder="Optional SOS message"
                       class="flex-1 bg-gray-700 border border-gray-600 rounded px-4 py-2 focus:outline-none focus:border-blue-500">
                <button onclick="sendSOS()" class="bg-red-600 hover:bg-red-700 px-8 py-2 rounded font-bold transition text-lg">
                    üö® SEND SOS
                </button>
            </div>
        </div>

        <!-- Debug Section -->
        <div class="bg-gray-800 rounded-lg p-6 mt-6">
            <h2 class="text-2xl font-semibold mb-4 text-yellow-400">üîß Debug Tools</h2>
            <div class="grid grid-cols-2 gap-4">
                <button onclick="checkRedisKeys()" class="bg-yellow-600 hover:bg-yellow-700 px-4 py-2 rounded transition">
                    üîç Check Redis Keys
                </button>
                <button onclick="testEcho()" class="bg-teal-600 hover:bg-teal-700 px-4 py-2 rounded transition">
                    üîä Test Echo Event
                </button>
            </div>
        </div>

        <!-- Event Logs -->
        <div class="bg-gray-800 rounded-lg p-6 mt-6">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-semibold text-cyan-400">üìã Event Logs</h2>
                <button onclick="clearLogs()" class="bg-gray-700 hover:bg-gray-600 px-4 py-2 rounded text-sm transition">
                    üóëÔ∏è Clear Logs
                </button>
            </div>
            <div id="logs" class="bg-gray-900 rounded p-4 h-96 overflow-y-auto font-mono text-sm space-y-2">
                <div class="text-gray-500">Waiting for events...</div>
            </div>
        </div>
    </div>

    <script>
        let socket = null;
        let autoLocationInterval = null;

        // Utility: Log to UI
        function log(message, type = 'info') {
            const logsDiv = document.getElementById('logs');
            const timestamp = new Date().toLocaleTimeString();
            const colors = {
                info: 'text-blue-400',
                success: 'text-green-400',
                error: 'text-red-400',
                warning: 'text-yellow-400',
                event: 'text-purple-400'
            };
            
            const logEntry = document.createElement('div');
            logEntry.className = colors[type];
            logEntry.innerHTML = `<span class="text-gray-500">[${timestamp}]</span> ${message}`;
            logsDiv.appendChild(logEntry);
            logsDiv.scrollTop = logsDiv.scrollHeight;
        }

        // Update connection status
        function updateStatus(status, connected) {
            const statusDiv = document.getElementById('connectionStatus');
            const statusText = document.getElementById('statusText');
            statusText.textContent = status;
            
            if (connected) {
                statusDiv.className = 'p-4 rounded bg-gray-700 border-l-4 border-green-500';
            } else {
                statusDiv.className = 'p-4 rounded bg-gray-700 border-l-4 border-red-500';
            }
        }

        // Connect to Socket.IO server
        function connectSocket() {
            const serverUrl = document.getElementById('serverUrl').value;
            const token = document.getElementById('jwtToken').value.trim();

            if (!token) {
                log('‚ùå Please provide JWT token', 'error');
                alert('Please paste your JWT token first!');
                return;
            }

            log(`üîå Connecting to ${serverUrl}...`, 'info');

            socket = io(serverUrl, {
                auth: { token },
                transports: ['websocket', 'polling'],
                reconnection: true,
                reconnectionAttempts: 5,
                reconnectionDelay: 1000,
                timeout: 20000
            });

            // Connection Events
            socket.on('connect', () => {
                log(`‚úÖ Connected! Socket ID: ${socket.id}`, 'success');
                updateStatus(`Connected (${socket.id})`, true);
            });

            socket.on('connected', (data) => {
                log(`üì® Welcome message: ${JSON.stringify(data)}`, 'event');
            });

            socket.on('disconnect', (reason) => {
                log(`‚ùå Disconnected: ${reason}`, 'error');
                updateStatus('Disconnected', false);
            });

            socket.on('connect_error', (error) => {
                log(`‚ùå Connection error: ${error.message}`, 'error');
                updateStatus('Connection Error', false);
            });

            socket.on('reconnect', (attemptNumber) => {
                log(`üîÑ Reconnected after ${attemptNumber} attempts`, 'success');
                updateStatus(`Reconnected (${socket.id})`, true);
            });

            socket.on('reconnect_attempt', (attemptNumber) => {
                log(`üîÑ Reconnection attempt ${attemptNumber}...`, 'warning');
            });

            socket.on('reconnect_error', (error) => {
                log(`‚ùå Reconnection error: ${error.message}`, 'error');
            });

            socket.on('reconnect_failed', () => {
                log(`‚ùå Reconnection failed after all attempts`, 'error');
            });

            // Trip Events
            socket.on('participant_joined', (data) => {
                log(`üë§ ${data.userRole} joined the trip`, 'event');
            });

            socket.on('participant_left', (data) => {
                log(`üëã ${data.userRole} left the trip`, 'event');
            });

            socket.on('participant_disconnected', (data) => {
                log(`üîå ${data.userRole} disconnected`, 'warning');
            });

            socket.on('trip_status_changed', (data) => {
                log(`üîÑ Trip status: ${data.status}`, 'event');
            });

            socket.on('ambulance_assigned', (data) => {
                log(`üöë Ambulance assigned: ${data.ambulanceName} (${data.vehicleNumber})`, 'success');
            });

            // Location Events
            socket.on('location_updated', (data) => {
                log(`üìç ${data.userRole} location: [${data.location.latitude}, ${data.location.longitude}]`, 'event');
            });

            // Emergency Events
            socket.on('emergency_sos', (data) => {
                log(`üö® SOS ALERT from ${data.userRole}: ${data.message}`, 'error');
            });
        }

        // Disconnect
        function disconnectSocket() {
            if (!socket) {
                log('‚ùå Not connected', 'error');
                return;
            }
            socket.disconnect();
            socket = null;
            log('üîå Disconnected manually', 'info');
            updateStatus('Not Connected', false);
        }

        // Join Trip
        function joinTrip() {
            if (!socket) {
                log('‚ùå Not connected', 'error');
                return;
            }

            const tripId = document.getElementById('tripId').value.trim();
            if (!tripId) {
                log('‚ùå Please enter Trip ID', 'error');
                return;
            }

            socket.emit('join_trip', { tripId }, (response) => {
                if (response.success) {
                    log(`‚úÖ Joined trip: ${tripId}`, 'success');
                } else {
                    log(`‚ùå Failed to join: ${response.message}`, 'error');
                }
            });
        }

        // Leave Trip
        function leaveTrip() {
            if (!socket) {
                log('‚ùå Not connected', 'error');
                return;
            }

            const tripId = document.getElementById('tripId').value.trim();
            if (!tripId) {
                log('‚ùå Please enter Trip ID', 'error');
                return;
            }

            socket.emit('leave_trip', { tripId }, (response) => {
                if (response.success) {
                    log(`‚úÖ Left trip: ${tripId}`, 'success');
                } else {
                    log(`‚ùå Failed to leave: ${response.message}`, 'error');
                }
            });
        }

        // Get Trip Participants
        function getTripParticipants() {
            if (!socket) {
                log('‚ùå Not connected', 'error');
                return;
            }

            const tripId = document.getElementById('tripId').value.trim();
            if (!tripId) {
                log('‚ùå Please enter Trip ID', 'error');
                return;
            }

            socket.emit('get_trip_participants', { tripId }, (response) => {
                if (response.success) {
                    log(`üë• Participants (${response.count}): ${JSON.stringify(response.participants)}`, 'success');
                } else {
                    log(`‚ùå Failed: ${response.message}`, 'error');
                }
            });
        }

        // Send Location
        function sendLocation() {
            if (!socket) {
                log('‚ùå Not connected', 'error');
                return;
            }

            const tripId = document.getElementById('tripId').value.trim();
            const latitude = parseFloat(document.getElementById('latitude').value);
            const longitude = parseFloat(document.getElementById('longitude').value);

            if (!tripId) {
                log('‚ùå Please enter Trip ID', 'error');
                return;
            }

            socket.emit('location_update', {
                tripId,
                location: { latitude, longitude, accuracy: 10 }
            }, (response) => {
                if (response.success) {
                    log(`üì° Location sent: [${latitude}, ${longitude}]`, 'success');
                } else {
                    log(`‚ùå Failed: ${response.message}`, 'error');
                }
            });
        }

        // Auto Send Location
        function startAutoLocation() {
            if (autoLocationInterval) {
                log('‚ö†Ô∏è Auto-send already running', 'warning');
                return;
            }

            autoLocationInterval = setInterval(() => {
                // Simulate slight movement
                const lat = parseFloat(document.getElementById('latitude').value);
                const lng = parseFloat(document.getElementById('longitude').value);
                
                document.getElementById('latitude').value = (lat + Math.random() * 0.001).toFixed(4);
                document.getElementById('longitude').value = (lng + Math.random() * 0.001).toFixed(4);
                
                sendLocation();
            }, 3000);

            log('‚ñ∂Ô∏è Auto-send started (every 3 seconds)', 'success');
        }

        function stopAutoLocation() {
            if (autoLocationInterval) {
                clearInterval(autoLocationInterval);
                autoLocationInterval = null;
                log('‚èπÔ∏è Auto-send stopped', 'info');
            }
        }

        // Get Location
        function getLocation(targetRole) {
            if (!socket) {
                log('‚ùå Not connected', 'error');
                return;
            }

            const tripId = document.getElementById('tripId').value.trim();
            if (!tripId) {
                log('‚ùå Please enter Trip ID', 'error');
                return;
            }

            socket.emit('get_location', { tripId, targetRole }, (response) => {
                if (response.success) {
                    log(`üìç ${targetRole} location: ${JSON.stringify(response.location)}`, 'success');
                } else {
                    log(`‚ùå Failed: ${response.message}`, 'error');
                }
            });
        }

        // Send SOS
        function sendSOS() {
            if (!socket) {
                log('‚ùå Not connected', 'error');
                return;
            }

            const tripId = document.getElementById('tripId').value.trim();
            const message = document.getElementById('sosMessage').value.trim();

            if (!tripId) {
                log('‚ùå Please enter Trip ID', 'error');
                return;
            }

            socket.emit('emergency_sos', { tripId, message }, (response) => {
                if (response.success) {
                    log(`üö® SOS SENT!`, 'error');
                } else {
                    log(`‚ùå Failed: ${response.message}`, 'error');
                }
            });
        }

        // Clear Logs
        function clearLogs() {
            document.getElementById('logs').innerHTML = '<div class="text-gray-500">Logs cleared...</div>';
        }

        // Debug: Check Redis keys
        async function checkRedisKeys() {
            const tripId = document.getElementById('tripId').value.trim();
            if (!tripId) {
                log('‚ùå Please enter Trip ID first', 'error');
                return;
            }

            log('üîç Checking Redis keys...', 'info');
            log(`üì¶ Expected key: location:user:${tripId}`, 'info');
            log(`üì¶ Expected key: location:ambulance:${tripId}`, 'info');
            
            // Try to get both locations
            if (socket) {
                socket.emit('get_location', { tripId, targetRole: 'user' }, (res) => {
                    if (res.success) {
                        log(`‚úÖ User location exists in Redis`, 'success');
                    } else {
                        log(`‚ùå User location NOT in Redis: ${res.message}`, 'error');
                    }
                });

                socket.emit('get_location', { tripId, targetRole: 'ambulance' }, (res) => {
                    if (res.success) {
                        log(`‚úÖ Ambulance location exists in Redis`, 'success');
                    } else {
                        log(`‚ùå Ambulance location NOT in Redis: ${res.message}`, 'error');
                    }
                });
            }
        }

        // Test Echo
        function testEcho() {
            if (!socket) {
                log('‚ùå Not connected', 'error');
                return;
            }

            const testData = { message: 'Hello from client', timestamp: new Date().toISOString() };
            socket.emit('echo_test', testData, (response) => {
                log(`üîä Echo response: ${JSON.stringify(response)}`, 'success');
            });
        }
    </script>
</body>
</html>


================================================================================
FILE: tsconfig.json
================================================================================

{
  // Visit https://aka.ms/tsconfig to read more about this file
  "compilerOptions": {
    // File Layout
    "rootDir": "./src",
    "outDir": "./dist",

    // Environment Settings
    // See also https://aka.ms/tsconfig/module
    "module": "nodenext",
    "target": "esnext",
    "types": [],
    // For nodejs:
    // "lib": ["esnext"],
    // "types": ["node"],
    // and npm install -D @types/node

    // Other Outputs
    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,

    // Stricter Typechecking Options
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true,

    // Style Options
    // "noImplicitReturns": true,
    // "noImplicitOverride": true,
    // "noUnusedLocals": true,
    // "noUnusedParameters": true,
    // "noFallthroughCasesInSwitch": true,
    // "noPropertyAccessFromIndexSignature": true,

    // Recommended Options
    "strict": true,
    "jsx": "react-jsx",
    "verbatimModuleSyntax": true,
    "isolatedModules": true,
    "noUncheckedSideEffectImports": true,
    "moduleDetection": "force",
    "skipLibCheck": true,
  }
}


